Springboot;
@RestController -> Rest apiler için kullanılır
@Controller -> MVC projeler için kullanılır


Maven Commands;
- mvn clean install
- mvn spring-boot:run

- java -jar target/accounts-0.0.1-SNAPSHOT.jar


Docker Commands;
- docker build . -t merveyilmas/accounts:s4
(dockerfile olan dizinde dockerfile dan image oluşturur)
- docker images
(docker image leri listeler)
- docker inspect image 6121
(image id ye göre image bilgilerini listeler)

- terminalden docker desktop a login olmak için; docker login -u merveyilmas

- docker run -p 8080:8080 merveyilmas/accounts:s4 
(image ı container içinde çalıştırır)
- docker run -d -p 8080:8080 merveyilmas/accounts:s4
(-d ile "detech" container ı arka planda çalıştırırız)
(dışarıya açılan docker port : container içerisindeki proje çalışma portu)
- docker ps
(çalışan conatiner ları listeler)
- docker ps -a
(tüm container ları listeler)
- docker start e0443edcb6ac0541e8ff46d1aa221660f755985d78ddc904ae50d7bc0c998a65
(conatiner ıd ile container çalıştırır)


Accounts Dockerfile örneği;

#Start with a base image containing Java runtime
FROM openjdk:21-jdk-slim

# MAINTAINER instruction is deprecated in favor of using label
# MAINTAINER meryil.com
#Information around who maintains the image
LABEL "org.opencontainers.image.authors"="meryil.com"

# Add the application's jar to the image
COPY target/accounts-0.0.1-SNAPSHOT.jar accounts-0.0.1-SNAPSHOT.jar

# execute the application
ENTRYPOINT ["java", "-jar", "accounts-0.0.1-SNAPSHOT.jar"]


- Dockerfile oluşturmak için buildpacks ve GoogleJib kullanabiliriz.


BUILDPACKS:

Dockerfile olmadan buildpacks ile image oluşturmak için;

1. Packaging yöntemini ekle:
<version>0.0.1-SNAPSHOT</version>
<packaging>jar</packaging>

2. Image name i ekle:
<configuration>
	<image>
		<name>merveyilmas/${project.artifactId}:s4</name>
	</image>
	<excludes>
		<exclude>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</exclude>
	</excludes>
</configuration>

- <packaging> ve <image> i ilgili yerlere ekle pom.xml de
- mvn spring-boot:build-image
(maven ile image oluşturmak için bu komutu çalıştırdık)


GOOGLE JIB:

- Jib works only java applications.

1. Google jib plugin i pom.xmle e ekle.

<plugin>
<groupId>com.google.cloud.tools</groupId>
<artifactId>jib-maven-plugin</artifactId>
<version>3.4.4</version>
<configuration>
  <to>
    <image>merveyilmas/${project.artifactId}:s4</image>
  </to>
</configuration>
</plugin> 

2. mvn compile jib:dockerBuild
(google jib ile image oluşturduk)

- mvn compile jib:build
( Bu komut ile sistemde docker yüklü olmasa bile goggle jib ile image oluşturabiliriz.)


Push image to DockerHub;
- docker image push docker.io/merveyilmas/accounts:s4

Pull image to DockerHub;
- docker image pull merveyilmas/accounts:s4


Docker Compose;

- Docker Compose, birden fazla Docker konteynerini tanımlamak ve yönetmek için kullanılan bir araçtır. Genellikle mikro hizmet mimarileri ve çoklu konteyner uygulamaları geliştirenler tarafından kullanılır. Docker Compose, bir YAML dosyasına (docker-compose.yml) servisleri, ağları, hacimleri ve konteyner ayarlarını tanımlamanıza olanak tanır.

- docker compose version

- Docker compose dosyasını istediğimiz dizinde oluşturabiliriz. Dosya ismi docker-compose.yml olmalıdır.

- docker compose up -d
(docker compose dosyasını oluşturduğumuz yerde bu komut ile container ları oluşturup, microservisleri çalıştırabiliriz)

- docker compose stop
(tüm containerları durdurur, silmez)

- docker compose down
(tüm containerlerı siler)


CLOUD NATIVE APPLICATIONS;

- Cloud-native applications (bulut yerel uygulamalar), bulut ortamlarında çalışacak şekilde tasarlanmış ve geliştirilmiş uygulamalardır. Bu tür uygulamalar, bulutun sunduğu avantajlardan tam olarak faydalanacak şekilde yapılandırılır ve genellikle mikro hizmet mimarisi, konteynerler, otomatik ölçekleme, sürekli entegrasyon/sürekli dağıtım (CI/CD) gibi modern yazılım geliştirme yaklaşımlarını kullanır.

- Örnek Teknolojiler: 
Kubernetes: Konteynerlerin orkestrasyonu.
Docker: Konteyner teknolojisi.
Prometheus: İzleme ve uyarı sistemi.
Istio: Servis ağı ve mikro hizmetler için bir yönetim platformu.
Terraform: Altyapı otomasyonu.


12-Factor App ve 15-Factor App Metodolojileri;

- 12-Factor App ve 15-Factor App metodolojileri, bulut tabanlı uygulamaların geliştirilmesi ve dağıtılması için uygulama geliştirme süreçlerinde en iyi uygulamaları tanımlar. Bu metodolojiler, modern, mikro hizmet tabanlı uygulamaların esnek, taşınabilir ve sürdürülebilir olmasını sağlamak için çeşitli yönergeler sunar.

12-Factor App Metodolojisi;

- 12-Factor App metodolojisi, her bir uygulamanın bulut ortamında verimli çalışmasını sağlayacak şekilde geliştirilmesi için 12 temel prensipten oluşur. Bu prensipler, uygulamanın taşınabilirliğini, esnekliğini ve ölçeklenebilirliğini arttırmaya yönelik ipuçları sunar. 12-Factor, özellikle bulut yerel (cloud-native) uygulamalar için önemli bir rehberdir.

12-Factor Uygulama Prensipleri:

1. Codebase (Kod Tabanı): Uygulama, tek bir kod tabanından (repository) yönetilmelidir ve her ortamda (geliştirme, test, üretim) aynı kod tabanı kullanılmalıdır.

2. Dependencies (Bağımlılıklar): Uygulamanın bağımlılıkları açıkça tanımlanmalı ve bağımsız olarak yüklenebilmelidir. Yani, uygulama bağımlılıkları dışarıdan (örneğin, package.json, pom.xml) açıkça belirtmelidir.

3. Config (Yapılandırma): Yapılandırma verileri (veritabanı bağlantı bilgileri gibi), uygulamanın içinde değil, dış bir ortamda veya çevresel değişkenlerde saklanmalıdır.

4. Backing Services (Destekleyici Servisler): Veritabanları, mesajlaşma sistemleri gibi dış servisler, uygulamanın bir parçası gibi düşünülmeli, fakat ayrı birer servis olarak ele alınmalıdır.

5. Build, Release, Run (Yapı, Yayınlama, Çalıştırma): Uygulamanın derlenmesi (build), yayına alınması (release) ve çalıştırılması (run) süreçleri ayrılmalıdır. Her aşama açıkça tanımlanmalıdır.

6. Processes (İşlemler): Uygulama, durumu taşımayan (stateless) işlemlerle çalışmalıdır. Her işlem kendi başına bağımsız olmalı ve işlem sırasındaki herhangi bir kayıp, diğer işlemleri etkilememelidir.

7. Port Binding (Port Bağlama): Uygulama, bir web sunucusunu çalıştırmak için bir port üzerinden erişilebilir olmalıdır. Uygulama dışındaki proxy sistemleri yerine, uygulamanın kendisi doğrudan HTTP veya TCP portu üzerinden dinlemelidir.

8. Concurrency (Eşzamanlılık): Uygulama, artan talepleri karşılamak için çoklu iş parçacığı (concurrency) veya işlemlerle yatay olarak ölçeklenebilir olmalıdır.

9. Disposability (Geçici Olma): Uygulama, kısa süreli yaşam döngülerine sahip olmalı ve gerektiğinde hızlıca başlatılabilir ve sonlandırılabilir olmalıdır.

10. Dev/Prod Parity (Geliştirme ve Üretim Farkı): Geliştirme, test ve üretim ortamları arasındaki farklar minimumda tutulmalıdır. Geliştiriciler ve operasyon ekipleri arasındaki kopukluk azaltılmalıdır.

11. Logs (Loglar): Uygulama, log verilerini stdout (standart çıktı) üzerinden dışarıya göndermeli ve bu loglar merkezi bir sistemde toplanmalıdır.

12. Admin Processes (Yönetici İşlemleri): Yönetici ve bakım işlemleri (örneğin, veritabanı migration'ları) uygulamanın bir parçası olarak tanımlanmalı ve çalıştırılabilir olmalıdır.

15-Factor App Metodolojisi;

- 15-Factor App metodolojisi, 12-Factor App metodolojisinin bir uzantısıdır ve 12-Factor'a ek olarak bazı ekstra faktörler ekler. Bu faktörler, bulut tabanlı uygulamaların daha etkili bir şekilde yönetilmesi, izlenmesi ve yapılandırılmasına olanak sağlar.

15-Factor Uygulama Prensipleri:

- 15-Factor App, 12-Factor metodolojisinin temeline dayanarak daha detaylı bir yapı sağlar. Ekstra faktörler şunlardır:

13. Rate Limiting (Hız Limitleme): Uygulama, dışarıya açılan API'lar ve servislerle olan etkileşimlerde hız sınırlaması yapabilmelidir. Bu, istek başına alınabilecek yanıt sayısını sınırlayarak uygulamanın aşırı yüklenmesini engeller.

14. Backups (Yedekleme): Veritabanı ve diğer kritik servisler için düzenli yedekleme stratejileri tanımlanmalıdır. Bu, felaket durumlarında veri kaybını önler.

15. Health Checks (Sağlık Kontrolleri): Uygulama, çalışma durumunu düzenli olarak kontrol edebilecek sağlık kontrolü mekanizmalarına sahip olmalıdır. Bu sayede sistem hatalarına karşı otomatik olarak yanıt verilebilir.

12-Factor ve 15-Factor Karşılaştırması;

- 12-Factor App metodolojisi, bulut ortamlarında verimli çalışan ve sürdürülebilir uygulamalar geliştirmek için temel yönergeleri sağlar.
15-Factor App metodolojisi, 12-Factor metodolojisini genişleterek uygulama yönetimi ve izleme gibi ekstra faktörler ekler. Bu, büyük ölçekli sistemlerde daha iyi bir operasyonel yönetim sağlar.


CONGIFURATION MANAGEMENT IN MICROSERVICE;

Read properties in Springboot app:

1. Using @Value annotation; 

application.yml veya application.properties dosyasına tanımladığımız değişkenlere istediğimiz yerde erişebiliriz.

ÖR;
application.yml;

build:
  version: "1.0"
  
account controller;

@Value("${build.version}")
private String buildVersion;

2. Using Environment;

- Çevresel değişkenlere erişmek için kullanırız.

ÖR;

account controller;

@Autowired
private Environment environment;

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
	return ResponseEntity.status(HttpStatus.OK).body(environment.getProperty("JAVA_HOME"));
}

Açıklama;
// jdk nın yüklü olduğu dizini verir
environment.getProperty("JAVA_HOME")

// maven ın yüklü olduğu dizini verir
environment.getProperty("MAVEN_HOME")

3. Using @ConfigurationProperties;

-Birden fazla değişkene değer tanımlamak için kullanabiliriz.

ÖR;

application.yml;

accounts:
  message: "Welcome to EazyBank accounts related local APIs "
  contactDetails:
    name: "John Doe - Developer"
    email: "john@eazybank.com"
  onCallSupport:
    - (555) 555-1234
    - (555) 523-1345

AccountsContactInfoDto;

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {
}

AccountsApplication;

@SpringBootApplication
@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})

AccountsController;

@Autowired
private AccountsContactInfoDto accountsContactInfoDto;

@GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo() {
        return ResponseEntity.status(HttpStatus.OK).body(accountsContactInfoDto);
    }
    
Springboot Profiles;

- application_prod.yml ve application_qa.yml isminde iki ayrı profil oluşturduk.

application_qa.yml;

spring:
  config:
    activate:
      on-profile: "qa"

build:
  version: "2.0"

accounts:
  message: "Welcome to Meryil accounts related QA APIs "
  contactDetails:
    name: "Smitha Ray - QA Lead"
    email: "smitha@meryil.com"
  onCallSupport:
    - (666) 265-3765
    - (666) 734-8371

application.yml;

spring:
  config:
    import:
      - "application_qa.yml"
      - "application_prod.yml"
  profiles:
    active:
      - "qa"
      
- application.yml dosyasında profiles.active kısmında hangi profile in ismini yazarsak o yml dosyasındaki konfigürasyonlar çalışır.


Komut Satırı ile Profile Aktif Etme;

1. Program arguments ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede program arguments kısmına 

--spring.profiles.active=prod  --build.version=1.1 

şeklinde yazarak istediğimiz değişkeni set ederiz.

2. VM options ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede modify options kısmından 'Add VM options' seçeneğine tıklarız. Açılan sekmeye ise 

-Dspring.profiles.active=prod  -Dbuild.version=1.1

şeklinde yazarak istediğimiz jvm değişkenlerini set ederiz.

3. Environment Variables ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede environment variable kısmına

SPRING_PROFILES_ACTIVE=prod;BUILD_VERSION=1.8;

şeklinde yazarak istediğimiz değişkenlerini set ederiz.

- Eğer konfigürasyon dosyasında 3 alana da değişkenleri set edersek proje program arguments kısmında yazan değeri alır. 

- Eğer VM ve environment kısmında aynı aynda değişken set edilirse VM variable kısmmındaki değişkeni baz alır.

- Yani öncelik sırası;
Program arguments > VM options > Environment Variables


SPRING CLOUD CONFIG;

- Spring initializers dan spring config projesi oluşturduk.
Proje oluştururken dependency olarak "config server" ve "spring boot actuator" bağımlılıklarını seçtik.

1. Reading configurations from the class path location of config server;

- Config server projesinde "resources" dizini altına "config" klasörü ekledik. Config klasörü altına ise tüm yml dosyalarını taşıdık. (accounts.yml, accounts-prod.yml vs.) Serverconfig projesine aşağıdaki linkler ile istek atarak tanımlanan configürasyonlara erişim sağlarız.

- http://localhost:8071/accounts/default
- http://localhost:8071/accounts/prod
- http://localhost:8071/accounts/qa
- http://localhost:8071/loans/qa

- Config server a accounts, cards ve loans yml dosyaları eklendikten sonra accounts, cards ve loans projelerindeki prod ve qa konfigürasyonlarını siliyoruz.

- Accounts projesine config client dependency lerini ekliyoruz.

<properties>
	<java.version>21</java.version>
	<spring-cloud.version>2024.0.0</spring-cloud.version>
</properties>
	
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-config</artifactId>
</dependency>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>${spring-cloud.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>


- accounts projesindeki application.yml dosyasının son hali bu şekilde oluyor;

spring:
  application:
    name: accounts
  profiles:
    active: "prod"
  datasource:
    url: jdbc:mysql://localhost:3306/UdemyAccounts
    username: merve
    password: Merve123.
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      javax:
        persistence:
          validation:
            mode: none
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
  config:
    import: "optional:configserver:http://localhost:8071/"

application:
  version: 1.0.0

server:
  port: 8080

logging:
  level:
    org.springframework: error

---
application:
    name: accounts
---
- Bu kısımdaki name alanı configserver projesinde accounts projesi için oluşturulan yml dosyasının ismi ile aynı olmak zorunda.

- Aynı işlemleri lonas ve cards projeleri için de yapıyoruz.

2. Reading configurations from a file system location;
- configserver projesindeki konfigürasyonları barındıran config dosyasını kopyalayıp bilgisayarada bir dizine yapıştırdım. ("/home/merveyilmaz/Documents/config")

- Daha sonra ise configserver projesinde bulunan application.yml dosyasındaki config.server.native.search.locations kısmını dosya yolu olacak şekilde düzenliyoruz.

spring:
  application:
    name: "configserver"
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          #search-locations: "classpath:/config"
          search-locations: "file:///home/merveyilmaz/Documents/config"

3. Reading configurations from a github repository;

- github da public repository açıp config klasörü altındaki yml dosyalarını bu repository e pushluyoruz. Ardından configserver projesi altındaki application.yml dosyasında aşağıdaki düzenlemeleri yapıyoruz.

spring:
  application:
    name: "configserver"
  profiles:
    #active: native
    active: git
  cloud:
    config:
      server:
        #native:
          #search-locations: "classpath:/config"
          #search-locations: "file:///home/merveyilmaz/Documents/config"
        git:
          uri: "https://github.com/eazybytes/eazybytes-config.git"
          default-label: main
          timeout: 5
          clone-on-start: true
          force-pull: true

server:
  port: 8071


Encryption & Decryption of properties inside config server;

- config dosyamızı github a yüklediğimiz için verilerimizi göstermek istemeyiz. Config verilerini şifrelemek için configserver projesindeki application.yml dosyasına şu alanı ekleriz.

encrypt:
  key: "45D81EC1EF61DF9AD8D3E5BB397F9"

bu bizim şifreleme keyimiz olur.

http://localhost:8071/encrypt 
(body e şifrelemek istediğin text i koy body-raw-text)
http://localhost:8071/decrypt 
(body e config verisinin şifrelenmiş halini koy)

apileri ile şifreleme veya şifrelenmiş veriyi öğrenme işlemlerini gerçekleştirebiliriz.

- En son olarak ise şifrelemek istediğimiz veriyi şifreledikten sonra github da ilgili yere "{cipher}şifrelenmişveri" şeklinde güncelleriz.


Refresh configurations at runtime using REFRESH ACTUATOR PATH;

- Config dosyasında herhangi bir değişiklik yapıldığında projemiz otomatik algılasın istiyoruz.

- Mikroservislerin pom.xml dosyamızda actuator dependency i olması gerekir.

- Mikroservislerin ContactDto sınıflarını record dan normal class a dönüştürdük ki run time da herhangi bir değişiklik algılandığında değişkenler değişikliği alıgılayabilsin. 

@ConfigurationProperties(prefix = "loans")
@Getter @Setter
public class LoansContactInfoDto {

    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}

- Mikroservislerin application.yml dosyalarına şu konfigürasyonu ekliyoruz;

management:
  endpoints:
    web:
      exposure:
        include: "*"

- Githubdan accounts-prod.yml dosyasında bir string i değiştirdiğğimizde projeyi yeniden başlatmaya gerek kalmadan configürasyon dosyası proje tarafından otomatik algılanır. Githubdan string değiştirip config serverdan http://localhost:8071/accounts/prod adresine istek atarak test edebiliriz.

- Bu işlem actuator sayesinde olur.

- localhost:8080/actuator adresine istek atarak actuator ın sunduğu apileri görebiliriz.

- localhost:8080/actuator/refresh endpointi ile hangi property lerin değiştiğini görebiliriz.


Refresh configurations at runtime using Spring Cloud Bus;

- Spring cloud bus konfigürasyon dosyasınd aherhangi bir değişiklik olduğunda kaç adet mikroservis var ise hepsine aynı anda mesaj gönderir.

- Bunu rabbit mq ile yapacağız.
- Tüm mikroservis projelerimize ve configserver projemize aşağıdaki dependency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>

- Rabbitmq yu bilgisayarımıza docker komutu ile kuruyoruz
(# latest RabbitMQ 4.0.x
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management) - rabbit mq sitesinde var

- Daha sonra tüm mikroservislerdeki application.yml dosyasına rabbit mq konfigürasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
Spring Cloud Config monitor;

- Config repository de bir değişiklik olduğunda github webhook ile config servise bilgi verir. Config servis de rabbit mq ile mikroservislere mesaj gönderir. Mikroservisler de yeniden başlatılmasına gerek kalmadan kendilerini otomatik yenilerler.

- Spring Cloud Config Monitor, Spring Cloud Config Server ile birlikte çalışan bir mekanizmadır ve konfigürasyon değişikliklerini dinleyerek, ilgili mikroservisleri bu değişikliklerden haberdar eder. Bu sayede, bir servis manuel yeniden başlatılmadan yeni konfigürasyonu alabilir.

Nasıl Çalışır? 

1. Spring Cloud Config Server ile merkezi bir yapılandırma yönetimi sağlanır. Genellikle bir Git deposu kullanılır.

2. Spring Cloud Bus ile RabbitMQ veya Kafka gibi bir mesajlaşma altyapısı üzerinden mikroservislere bildirim gönderilir.

3. Spring Cloud Config Monitor, Git deposundaki yapılandırma değişikliklerini algılar ve bir Webhook (örneğin, GitHub veya GitLab Webhook’u) üzerinden bir HTTP isteği alır.

4. Gelen istek üzerine, ilgili servislere mesaj göndererek konfigürasyonlarını yenilemelerini sağlar.

- config server projesinde pom.xml dosyasına depency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-config-monitor</artifactId>
</dependency>

- config server application.yml dosyasına aşağıdaki konfigürasyonub ekliyoruz.

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- config server application.yml dosyasına rabbit mq konfigürasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
- Daha sonra github config dosyalarımızın bulunduğu (card-prod.yml, accounts.yml vb.) repositorymizde ayarlar kısmında webhook atif ediyoruz.


Update docker compose to adapt config server changes;

- docker-compose isminde mikroservislerin olduğu dizinde bir kalsör açtık ve daha önce oluşturduğumuz docker-compose.yml dosyasını bu kalsöre taşıdık. Son olarak configserver projemiz için de docker compose dosyasına konfigürasyonları ekledik.

- her bir mikroservis için docker-compose sayfasına enviroment değşkenleri tanımladık. 

Docker-compose dosyasının son hali;

services:
  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"

- Bu docker-compose dosyasına göre configserver container ın oluşturulması tamamlanmadan accounts containerını oluşturmaya başlayacak. Bu da mikroservislerimizin çalışmasını engel olur.


LIVENESS and READNESS probes;

- Liveness; projenin ayakta olup olmadığını kontrol eder.
- Readness; projede trafik akışı var mı onu kontrol eder.

- configserver projesindeki application.yml dosyasına konfigürasyonu ekliyoruz.

management:
  
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- actuator endpointleri ile projenin liveness ve readness durumlarını kontorl edebiliriz.

- localhost:8071/actuator/health
response;
{"status":"UP","groups":["liveness","readiness"]}

- localhost:8071/actuator/health/liveness
response;
{"status":"UP"}

- eğer porjede sorun var ise status ü down olur.


Update DOCKER COMPOSE file to adapt congfig server cahnges;

- docker compose dosyasında configserver containerına healthchech konfigürasyonları ekledik.

- accounts containerına depends_on ekleyerek, config serverın sağlıklı bir şekilde çalıştığına emin olunduktan sonra account container ı oluşturulmaya başlanacak.

- spring bus kullandığımız için bizim projelerin çalışması rabbit  mq projesine de bağlı. bu yüzden compose dosyasına rabbit mq servisini de docker compose dosyamıza ekliyoruz.

- docker compose dosyasının son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
      
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"


OPTIMIZE DOCKER COMPOSE FILE;

- docker-compose dosyamızda tekrar eden konfigürasyonları common-config.yml adında dosya oluşturup oraya taşıdık.

- docker-compose.yml son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "accounts"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "loans"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "cards"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

networks:
  meryilbank:
    driver: "bridge"

- common-config.yml dosyası;

services:

  network-deploy-service:
    networks:
      - meryilbank

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m
    environment:
      SPRING_RABBITMQ_HOST: "rabbit"

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
      

Generate docker image and push them to docker hub;

- İlk olarak tüm projelerin google jib ile image ını oluşturuyoruz.
(mvn compile jib:dockerBuild) komutunu kullanarak proje dizininde.

- daha sonra oluşturulan imageleri 
docker image push docker.io/merveyilmas/configserver:s6
komutu ile teker teker hub a pushladık.


DOCKER COMPOSE ile container oluşturma;

- Oluşturduğumuz docker-compose/default dizinindeki docker-compose dosyamızı
docker compose up -d
komutu ile çalıştırıyoruz.

- docker compose down 
ise oluşturulan tüm containerler ı siler.


CREATE MYSQLDB FOR MICROOSERVICES;

- docker run -p 3306:3306 --name accountsdb -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=accountsdb  -d mysql
komutu ile mysql db container ı oluşturduk.


UPDATE DOCKER COMPOSE FILE TO CREATE USE MYSQL DB;

- ilk olarak mikroservislerimizin image lerini oluşturuyoruz.
(mvn compile jib:dockerBuild) komutu ile

- Daha sonra docker-compose dosyamızı güncelliyoruz, db konfigürasyonları ekliyoruz. Dockor-compose dosyamızı çalıştırmak için "docker compose up" komutunu dosyamızın olduğu dizinde çalıştırıyoruz.


SERVICE DISCOVERY & SERVIICE REGISTRATION in MICROSERVICE:

Spring cloud support for client-side service discovery;

- spring cloud netflix's eureka (for service discovery)
- spring cloud load balancer
- netflix feign client 


EUREKASERVER;

- Eureka Server, Spring Cloud Netflix kütüphanesinin bir parçası olan ve mikro servis mimarisinde servis keşfi (Service Discovery) sağlayan bir bileşendir.

- Spring initializerdan eurekaserver projesi oluşturuyoruz. Proje oluştururken 'Eureka Server', 'Config Client' ve 'Spring Boot Actuator' dependency lerini eklememiz gerekir.

- Daha sonra projemizin EurekaserverApplication klasöründe @EnableEurekaServer anatasyonunu tanımlıyoruz.

- projemizdeki application.yml dosyasına ilgili konfigürasyon ayarlarını ekliyoruz.

- ayrıca config dosyalarımızın bulunduğu klasörümüze eurekaserver.yml dosyamızı ekliyoruz. yine ilgili konfigürasyonlarımızı yazıyoruz.

- daha sonra eurekaserver projemizi çalıştırdıktan sonra 'http://localhost:8070/' adresini ziyaret ettiğimizde eureka server panelimize ulaşıyoruz.


CONNECT EUREKA SERVER from MICROSERVICE;

-  Eureka server a bağlanmak istediğimiz mikroservislerin pom.xml dosyasına
aşağıdaki dependency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

- Ardından accounts mikroservisi içerisindeki application.yml dosyasına aşağıdaki konfigürasyonları ekliyoruz.

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    shutdown:
      access: unrestricted
  info:
    env:
      enabled: true

eureka:
  instance:
    preferIpAddress: true
  client:
    fetchRegistry: true # Kayıtları çekmesini aktif et
    registerWithEureka: true # Kendi kendini kayıt etmesini aktif et
    serviceUrl:
      defaultZone: http://localhost:8070/eureka/

info:
  app:
    name: "accounts"
    description: "Meryil Bank Account Application"
    version: "1.0.0"
    
- Accounts mikroservisine konfigürasyonları ekledikten sonra projemizi ayağa kaldırabiliriz.

- Account mikroservis ayağa kalktıktan sonra eureka server a bağlanıp bağlanmadığını "http://localhost:8070/" adresinden (euureka server proje portu) kontrol edebiliriz. Ayrıca http://localhost:8070/ adresinde mikroservis ismine tıklayarak application dosyasına tanımladığımız mikroservis info bilgilerine ulaşabiliriz. (http://192.168.80.171:8080/actuator/info)

- Bu konfigürasyonları cards ve loans mikroservislerine de uygulayacağız.

- http://localhost:8070/eureka/apps adresinden eureka server a bağlanan tüm mikroservis bilgilerini görebiliriz.

!NOT: Mikroservislerimizi ayağa kaldırmadan önce ilk "configserver" ı daha sonra "eurekaserver" ı ayağa kaldırmamız gerekir. Yoksa mikroservisimiz çalışmaz.

- http://localhost:8080/actuator/shutdown
- http://localhost:8090/actuator/shutdown
- http://localhost:9000/actuator/shutdown
yukarıdaki gibi mikroservislere istek attığımızda çalışmalarını durdurabiliriz.

!NOT: Mikroservisler her 30 saniyede bir eureka server a heartbeat gönderirler. Ayakta olduklarını söylemek için.


FEIGN CLIENT;

- İlk olarak ilgili dependency i mikroservislerimize ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

- Daha sonra application dosyalarına @EnableFeignClients anatasyonunu ekliyoruz.

- Accounts mikroservisinde service paketi altına client adında bir paket ekliyoruz. Ve istek atacağımız service için bir interface oluşturuyoruz.

Ör;

@FeignClient("cards")
public interface CardsFeignClient {

    @GetMapping(value = "/api/fetch", consumes = "application/json")
    public ResponseEntity<CardsDto> fetchCardDetails(@RequestParam String mobileNumber);
}

- Burada @FeignClient("cards") eurekaserverda mikroservis ismi ne ise anatasyon içerisine de o ismi yazıyoruz.

- Böylece mikroservislerimiz feign client aracılığı ile eurekaserver a istek atarlar ve eurekaserver da istek atılan mikroservise yönlendirir.


EUREKA SERVER Self-Preservation MODE;

- Eureka Server'ın Self-Preservation Mode (Kendini Koruma Modu), ağ kesintileri veya ani servis kayıpları gibi durumlarda yanlışlıkla sağlıklı servisleri silmemek için geliştirilmiş bir mekanizmadır.

Neden Gerekli?
Eureka Client'lar belirli aralıklarla heartbeat (kalp atışı) mesajları göndererek Eureka Server’a hala çalıştıklarını bildirir. Ancak ağ bağlantısı koparsa veya gecikmeler yaşanırsa, Eureka Server client'ların aslında çalışıyor olup olmadığını anlayamaz.

Eğer Self-Preservation Mode kapalı olursa ve Eureka belirlenen süre içinde heartbeat alamazsa, servisi kayıttan siler. Ancak bu bazen hatalı olabilir, çünkü servis çalışıyor olabilir fakat sadece geçici bir ağ sorunu yaşanıyor olabilir.

Bunu önlemek için Self-Preservation Mode, belirli bir eşik değerinin altına düşmedikçe servisleri silmemeyi tercih eder.

DOCKER COMPOSE dosyasını güncelleme eureka servis için;

- İlk olarak eurekaserver a google jib dependency i ekliyoruz image oluşturabilmek için.

- docker-compose.yml dosyası son hali;

services:

#  accountsdb:
#    container_name: accountsdb
#    ports:
#      - 3307:3306
#    environment:
#      MYSQL_DATABASE: accountsdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config
#
#  cardsdb:
#    container_name: cardsdb
#    ports:
#      - 3308:3306
#    environment:
#      MYSQL_DATABASE: cardsdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config
#
#  loansdb:
#    container_name: loansdb
#    ports:
#      - 3309:3306
#    environment:
#      MYSQL_DATABASE: loansdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config

  configserver:
    image: "merveyilmas/configserver:s8"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  eurekaserver:
    image: "merveyilmas/eurekaserver:s8"
    container_name: eurekaserver-ms
    ports:
      - "8070:8070"
    depends_on:
      configserver:
        condition: service_healthy
    healthcheck:
      test: "curl --fail --silent localhost:8070/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-configserver-config
    environment:
      SPRING_APPLICATION_NAME: "eurekaserver"

  accounts:
    image: "merveyilmas/accounts:s8"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    environment:
      SPRING_APPLICATION_NAME: "accounts"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://accountsdb:3306/accountsdb"
    depends_on:
#      accountsdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  loans:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms
    ports:
      - "8090:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://loansdb:3306/loansdb"
    depends_on:
#      loansdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  cards:
    image: "merveyilmas/cards:s8"
    container_name: cards-ms
    ports:
      - "9000:9000"
    environment:
      SPRING_APPLICATION_NAME: "cards"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://cardsdb:3306/cardsdb"
    depends_on:
#      cardsdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

networks:
  meryilbank:
    driver: "bridge"


- common-config.yml dosyası son hali;

services:

  network-deploy-service:
    networks:
      - meryilbank

#  microservice-db-config:
#    extends:
#      service: network-deploy-service
#    image: mysql
#    healthcheck:
#      test: [ "CMD", "mysqladmin" ,"ping", "-h", "localhost" ]
#      timeout: 10s
#      retries: 10
#      interval: 10s
#      start_period: 10s
#    environment:
#      MYSQL_ROOT_PASSWORD: root

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
      #SPRING_DATASOURCE_USERNAME: root
      #SPRING_DATASOURCE_PASSWORD: root

  microservice-eureka-config:
    extends:
      service: microservice-configserver-config
    environment:
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eurekaserver:8070/eureka/
      
Load balancing;

  loans:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms
    ports:
      - "8090:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_DATASOURCE_URL: "jdbc:mysql://host.docker.internal:3306/UdemyLoans"
    depends_on:
#      loansdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-eureka-config

  loans1:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms1
    ports:
      - "8091:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_DATASOURCE_URL: "jdbc:mysql://host.docker.internal:3306/UdemyLoans"
    depends_on:
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-eureka-config

- Docker compose dosyamızda yukarıdaki gibi iki tane loans container ı tanımlarsak eurekaserver arka planda loans mikroservisine gelen istekleri yoğunluğa göre iki mikroservise dağıtır.


API Gateway;

- Spring Cloud Gateway, Spring ekosisteminde API Gateway olarak kullanılan hafif ve ölçeklenebilir bir çözümdür. API Gateway, mikro hizmet mimarisinde istemciler (frontend, mobil uygulamalar vb.) ile arka plandaki servisler arasında bir giriş noktası olarak çalışır.

🚀 Spring Cloud Gateway’in Temel Özellikleri:
✅ Reverse Proxy: Gelen HTTP isteklerini uygun mikro servislere yönlendirir.
✅ Route (Yönlendirme): Belirli kurallara (URL pattern, header, vs.) göre istekleri belirli servislere iletir.
✅ Filter (Filtreleme): Gelen ve giden istekler üzerinde değişiklik yapabilir (örneğin, JWT doğrulama, CORS işlemleri, loglama).
✅ Load Balancing: Gelen trafiği farklı servis kopyalarına yönlendirebilir.
✅ Circuit Breaker: Servislerin çökmesini önlemek için koruyucu mekanizmalar sunar (Resilience4J gibi).
✅ Rate Limiting: Belirli bir süre içinde belirli sayıda isteğe izin vererek DDOS saldırılarına karşı koruma sağlar.

- Gateway için spring boot projemizi oluşturuyoruz ve aşağıdaki bağımlılıkları ekliyoruz.


  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <scope>runtime</scope>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

- pom.xml dosaysına google jib bağımlılığını ekliyoruz, image oluşturabilmek için

<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
		</plugin>
		<plugin>
			<groupId>com.google.cloud.tools</groupId>
			<artifactId>jib-maven-plugin</artifactId>
			<version>3.4.4</version>
			<configuration>
				<to>
					<image>merveyilmas/${project.artifactId}:s9</image>
				</to>
			</configuration>
		</plugin>
	</plugins>
</build>

- config repository sine gatewayserver.yml dosyasını ekliyoruz ve aşağıdaki konfigürasyonları tanımlıyoruz.

server:
  port: 8072

eureka:
  instance:
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: "http://localhost:8070/eureka/"


- gatewayserver projesindeki application.yml dosyasına da aşağıdaki konfigürasyonları ekliyoruz.

spring:
  application:
    name: "gatewayserver"
  config:
    import: "optional:configserver:http://localhost:8071/"
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      access: unrestricted
  info:
    env:
      enabled: true

info:
  app:
    name: "gatewayserver"
    description: "Meryil Bank Gatewayserver Application"
    version: "1.0.0"
    
- mikroservisleri çalıştırma sırası;
configserver -> eurekaserver -> accounts, loans, cards -> gatewayserver

- http://localhost:8072/actuator
ile gateway server ın actuator endpointlerini listeleriz.

- http://localhost:8072/actuator/gateway/routes
endpoint'i Spring Cloud Gateway tarafından yönetilen tüm aktif rotaları (routes) JSON formatında döndürür. (accounts, loans, cards)

- http://localhost:8072/ACCOUNTS/api/create
gateway routesdan öğrendiğimiz yol ile accounts mikroservisine yukarıdaki gibi istek atarız.

- accounts mikroservisine yukarıdaki gibi istek atarken mikroservis ismini ACCOUNTS gibi büyük yazmamız gerekir bu şekilde tanımlı olduğu için. Mikroservis ismini küçük harflerle yazabilmek için gateway servisine 

spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
          lowerCaseServiceId: true

konfigürasyonunu ekledik. Yani şimdi "http://localhost:8072/accounts/api/fetch?mobileNumber=1234567670" şeklinde istek atabiliriz.

- Mikroservis endpointlerimizi konfigüre etmek için "GatewayserverApplication" dosyamıza aşağıdaki fonksiyonu ekledik.

@Bean
public RouteLocator meryilBankRouteConfig(RouteLocatorBuilder routeLocatorBuilder) {
	return routeLocatorBuilder.routes()
			.route(p -> p
					.path("/meryilbank/accounts/**")
					.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://ACCOUNTS")) // eureka serverdaki mikroservis adı ne ise o olacak
			.route(p -> p
					.path("/meryilbank/loans/**")
					.filters( f -> f.rewritePath("/meryilbank/loans/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://LOANS"))
			.route(p -> p
					.path("/meryilbank/cards/**")
					.filters( f -> f.rewritePath("/meryilbank/cards/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://CARDS")).build();
}

şimdi ise hem "http://localhost:8072/accounts/api/fetch?mobileNumber=1234567670" hem de "http://localhost:8072/meryilbank/accounts/api/fetch?mobileNumber=1234567670" endpointleri ile istek atabiliriz.

Tracing/Logging using GATEWAY;

- Spring Cloud API Gateway'deki filters (filtreler), gelen ve giden HTTP isteklerini değiştirmek veya yönlendirmek için kullanılır. Filtreler, istekleri ve yanıtları inceleyerek güvenlik, doğrulama, yönlendirme, dönüşüm ve diğer işlevleri yerine getirebilir.

Ne İşe Yarar?
*Güvenlik: Kimlik doğrulama ve yetkilendirme işlemleri yapabilir.
*Loglama & İzleme: Gelen ve giden istekleri izleyip loglayabilir.
*Dönüştürme: İstek veya yanıt verilerini değiştirebilir (örn. JSON'dan XML'e çevirme).
*Rate Limiting: Belirli bir süre içinde belirli bir sayıda isteğe izin verebilir.
*Yönlendirme & Manipülasyon: URI değiştirme, başlık ekleme gibi işlemleri gerçekleştirebilir.


- gatewayserver projemize "filters" adında bir paket ekliyoruz be bu pakete de FilterUtility, RequestTraceFilter ve ResponseTraceFilter sınıflarını içerisindeki konfigürasyonlar ile beraber ekliyoruz.

FilterUtility;

- Bu sınıf, HTTP isteklerinin başlıklarıyla (headers) ilgili bazı yardımcı işlevler sağlar ve correlation id (ilişkilendirme kimliği) gibi başlıkları yönetir. FilterUtility sınıfı, özellikle API Gateway veya servisler arası iletişimde kullanılan Correlation ID'yi alıp set etme işlemlerini yapar. Correlation ID, genellikle dağıtık sistemlerde her isteği izlemek ve hata ayıklamak için kullanılır.

Özetle Ne Yapar?
Correlation ID Okuma: Gelen isteklerdeki eazybank-correlation-id başlığını alır.
Yeni Başlık Ekleme: İstek üzerine verilen başlık adını ve değerini ekler.
Correlation ID Ekleme: Gelen isteğe ya da yeni oluşturulan isteğe correlation-id başlığı ekler.
Bu sınıf, özellikle mikroservisler arasındaki isteklerin izlenebilirliğini artırmak için faydalıdır. Correlation ID, bir isteğin tüm yaşam döngüsünü takip etmek için kullanılır ve bu sınıf, bu başlıkla ilgili işlemleri yönetmek için basit bir yardımcı işlev sağlar.

RequestTraceFilter;

- Bu sınıf, Spring Cloud Gateway'de global bir filtre olarak çalışır ve her gelen HTTP isteğinde correlation-id başlığını yönetir. Amaç, gelen isteklerde correlation-id olup olmadığını kontrol etmek, yoksa yeni bir tane oluşturmak ve istek başlıklarına eklemektir. Ayrıca, loglama yaparak, her iki durumu da (başlık var mı, yoksa oluşturuldu) izler.

Özetle Ne Yapar?
Correlation ID Kontrolü:

Her gelen istek için, correlation-id başlığının mevcut olup olmadığını kontrol eder.
Eğer başlık varsa, var olan correlation-id'yi loglar.
Eğer başlık yoksa, yeni bir correlation-id oluşturur, başlıklara ekler ve bunu loglar.
Loglama:

logger.debug() kullanarak, işlem sırasında correlation-id'nin mevcut olup olmadığını ve hangi correlation-id'nin kullanıldığını debug seviyesinde loglar.
Correlation ID Ekleme:

Eğer correlation-id yoksa, yeni bir UUID oluşturup istek üzerine ekler. Bu sayede dağıtık sistemlerdeki tüm işlemler izlenebilir hale gelir.
Kullanım Senaryosu
Mikroservis Mimarisi: Bir API Gateway üzerinden gelen isteklerin takip edilmesini sağlar. Eğer bir isteğin correlation-id'si yoksa, bu sınıf bir tane oluşturur ve böylece tüm sistemdeki mikroservisler arasında bu isteğin izlenebilirliğini artırır. Bu, hata ayıklama, izleme ve performans takibi için kritik olabilir.

ResponseTraceFilter;

- Bu sınıf, Spring Cloud Gateway'de gelen ve giden istekler için correlation-id başlığını işleyen bir GlobalFilter oluşturur. Özellikle, giden yanıtlara correlation-id başlığını ekler. ResponseTraceFilter sınıfı, isteklerin ardından yapılan işlemler için giden yanıt başlıklarına correlation-id ekleyerek, yanıtları da izlenebilir kılar.

Özet
Bu sınıf, her gelen isteğin yanıtına correlation-id başlığını ekleyerek, tüm sistemdeki işlemlerin izlenmesini sağlar. Yani, isteklerdeki correlation-id, yanıtlara da aktarılır ve sistemdeki bütün işlem adımları arasındaki ilişkiyi izlemeye yardımcı olur.

- gatewayserver projemizde application.yml dosyasına detaylı logları görüntülemek için aşağıdaki konfigürasyonu ekliyoruz.

logging:
  level:
    com:
      meryilbank:
        gatewayserver: DEBUG
        

- Daha sonra log konfigürasyonlarını diğer mikroservislere de (accounts, loans ve cards) a ekliyoruz.

- Eklediğimiz konfigürasyon sonucu gatewayserver run terminalde aşağıdaki correlation-id
loglarını görüyoruz.

2025-03-18T15:43:51.932+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.RequestTraceFilter         : meryilbank-correlation-id generated in RequestTraceFilter : 2b80f73b-225d-4f39-9cad-1661e4f16bb7
2025-03-18T15:43:51.938+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.ResponseTraceFilter        : Updated the correlation id to the outbound headers: 2b80f73b-225d-4f39-9cad-1661e4f16bb7
2025-03-18T15:45:00.131+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.RequestTraceFilter         : meryilbank-correlation-id generated in RequestTraceFilter : efdb2c96-e333-4b87-97df-fa6bad4b781c
2025-03-18T15:45:00.349+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.ResponseTraceFilter        : Updated the correlation id to the outbound headers: efdb2c96-e333-4b87-97df-fa6bad4b781c
        
Correlation ID;

- Correlation ID (ilişkilendirme kimliği), dağıtık sistemlerde bir isteği, onunla ilişkili tüm işlemlerle takip etmek ve izlemek için kullanılan benzersiz bir tanımlayıcıdır. Özellikle mikroservis mimarilerinde, bir kullanıcının veya bir sistemin başlattığı işlem sırasındaki tüm adımların (istekler, yanıtlar, hata mesajları vb.) izlenebilmesi için kullanılır. Bu sayede bir işlem süreci boyunca farklı servisler arasında yapılan çağrılar birbirine bağlanabilir.

- accounts, loans ve cards mikroservislerinin bazı controller fonksiyonlarına correlationId değişkenini ekliyoruz.

Ör;
@GetMapping("fetchCustomerDetails")
public ResponseEntity<CustomerDetailsDto> fetchCustomerDetails(@RequestHeader("meryilbank-correlation-id") String correlationId,
                                                           @RequestParam
                                                           @Pattern(regexp = "(^$|[0-9]{10})", message = "Mobile number must be 10 digits")
                                                           String mobileNumber) {
logger.debug("meryilBank-correlation-id found: {} ", correlationId);
CustomerDetailsDto customerDetailsDto = iCustomersService.fetchCustomerDetails(mobileNumber, correlationId);
return ResponseEntity.status(HttpStatus.SC_OK).body(customerDetailsDto);
}
    
Design Patterns Around API Gateway;

API Gateway Pattern;

- API Gateway Pattern, mikro hizmet mimarisinde sıkça kullanılan bir tasarım desenidir. API Gateway, istemciler (mobil uygulamalar, web istemcileri vb.) ile mikro hizmetler arasında bir aracı katman olarak görev yapar. Temel amacı, istemcilerin doğrudan mikro hizmetlere erişmesini engelleyerek güvenliği, yönetilebilirliği ve performansı artırmaktır.

API Gateway’in Çalışma Mekanizması
İstemci, API Gateway’e HTTP isteği gönderir.
API Gateway, isteği inceler, kimlik doğrulama gibi işlemleri gerçekleştirir.
API Gateway, uygun mikro hizmete isteği yönlendirir ve yanıtı alır.
Yanıt, API Gateway tarafından formatlanarak istemciye iletilir.

Gateway Routing Pattern;

- Gateway Routing Pattern, API Gateway’in gelen HTTP isteklerini uygun mikro hizmetlere yönlendirmesini (routing) sağlayan bir tasarım desenidir. Bu desen, API Gateway’in sadece bir proxy olarak çalışmasını değil, aynı zamanda gelen istekleri inceleyerek dinamik veya statik kurallara göre yönlendirme yapmasını içerir.

📌 Gateway Routing Pattern’in Avantajları
✅ Mikro hizmetlerin gizlenmesi → Dış dünyaya doğrudan açılmazlar.
✅ İstek yönlendirme ve dönüştürme → API Gateway, ihtiyaca göre path veya parametreleri değiştirebilir.
✅ Güvenlik ve doğrulama → JWT, OAuth gibi kimlik doğrulama mekanizmalarıyla entegre edilebilir.
✅ Yük dengeleme (Load Balancing) → Gelen trafiği ölçeklenebilir şekilde farklı instancelara dağıtabilir.
✅ Önbellekleme ve hızlandırma → Sık yapılan istekleri Gateway üzerinde cache’leyebilir.

Gateway Offloading Pattern;

- Gateway Offloading Pattern, API Gateway’in kimlik doğrulama, güvenlik, hız sınırlama (rate limiting), önbellekleme (caching) ve yük dengeleme (load balancing) gibi işlemleri üstlenmesini sağlayan bir tasarım desenidir. Bu sayede mikro hizmetler sadece iş mantığına odaklanır ve ekstra yükten kurtulmuş olur.

📌 API Gateway Offloading Kullanım Senaryoları
✅ Kimlik doğrulama (OAuth, JWT) mikro hizmetlerden alınır, Gateway’e yüklenir.
✅ Rate limiting (Hız sınırlama) sayesinde DDoS saldırıları Gateway seviyesinde engellenir.
✅ Mikro hizmetler sadece iş mantığına odaklanır, güvenlik ve yük yönetimi API Gateway’e devredilir.
✅ Önbellekleme ile gereksiz istekler engellenir, performans artar.

Backend for Frontend (BFF) Pattern;

- Backend for Frontend (BFF) Pattern, farklı istemci türleri (web, mobil, IoT vb.) için özelleştirilmiş API'ler sunan bir backend katmanı oluşturmayı amaçlayan bir mimari desendir.

Klasik API Gateway yaklaşımının aksine, her istemci (mobil/web) için ayrı bir backend servis çalıştırılır.

📌 Neden BFF Kullanılır?
Farklı istemcilerin ihtiyaçları farklıdır:

Mobil uygulamalar daha az veri çeker, düşük gecikme ister.
Web istemcileri daha geniş veri setlerine erişebilir.
IoT cihazları genellikle hafif ve düşük güç tüketimli istekler yapar.
BFF, her istemciye özel bir API sunarak gereksiz veri ve iş yükünü azaltır.

📌 Sonuç
🔹 Backend for Frontend Pattern, her istemciye özel API sunarak performans, ölçeklenebilirlik ve özelleştirme açısından büyük avantajlar sağlar.
🔹 API Gateway yerine değil, onunla birlikte kullanılabilir!
🔹 Özellikle büyük ölçekli projelerde, mobil ve web istemcileri arasında büyük farklılıklar varsa önerilir.

Gateway Aggregator Pattern;

- Gateway Aggregator Pattern (diğer adıyla Composition Pattern), API Gateway’in birden fazla mikro hizmetten gelen verileri toplayarak tek bir istemci yanıtı oluşturmasını sağlayan bir tasarım desenidir.

Klasik mikro hizmet yaklaşımında, istemciler (mobil/web) farklı mikro hizmetlerden ayrı ayrı veri çekmek zorundadır. Bu durum:

Ağ trafiğini artırır.
İstemcinin fazladan iş yükü taşımasına neden olur.
Gecikmeleri artırabilir.
Gateway Aggregator Pattern, bu istekleri API Gateway üzerinden birleştirerek istemciye tek bir API çağrısı ile optimize edilmiş bir yanıt sunar.

📌 Neden Gateway Aggregator Kullanılır?
✅ Mikro hizmetler istemciden gizlenir.
✅ İstemci daha az API çağrısı yapar.
✅ Ağ trafiği azalır, performans artar.
✅ Veri birleştirme (composition) API Gateway tarafından yapılır.
✅ Mobil cihazlar için optimize edilmiş daha küçük yanıtlar sağlanabilir.

📌 Gateway Aggregator Çalışma Mantığı
1️⃣ İstemci, API Gateway'e tek bir istek yapar.
2️⃣ API Gateway, farklı mikro hizmetlerden veri çeker.
3️⃣ Verileri birleştirerek (compose) istemciye tek bir yanıt olarak döner.


Add Gatewayserver to Docker Compose File;

- İlk olarak accounts, loans ve cards a ayakta olduklarını anlamak için docker comppose da aşağıdaki konfigürasyonu ekledik.

healthcheck:
	test: "curl --fail --silent localhost:9000/actuator/health/readiness | grep UP || exit 1"
	interval: 10s
	timeout: 5s
	retries: 10
	start_period: 10s

- Ve gatewayserver için de docker compose dosyasına aşağıdaki yapılandırmayı ekledik.

  gatewayserver:
    image: "merveyilmas/gatewayserver:s9"
    container_name: gatewayserver-ms
    ports:
      - "8072:8072"
    depends_on:
      accounts:
        condition: service_healthy
      loans:
        condition: service_healthy
      cards:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "gatewayserver"
    extends:
      file: common-config.yml
      service: microservice-eureka-config


MAKING MICROSERVICE RESIELLIENT(Dayanıklı);

Resilience4j;
- Resilience4j, Java için geliştirilmiş, mikroservis mimarilerinde yaygın olarak kullanılan hata toleransı (fault tolerance) sağlayan hafif (lightweight) bir kütüphanedir.

📌 Temel Amacı Nedir?
Dağıtık sistemlerde oluşabilecek gecikmeleri, başarısızlıkları veya yoğun yükleri yönetilebilir hale getirmek.

🔧 Resilience4j'nin Sağladığı Temel Modüller
Modül	Açıklama
Circuit Breaker: Hatalı çalışan sistem çağrılarını keserek sistemi korur.
Rate Limiter: Belirli bir zaman aralığında yapılabilecek çağrı sayısını sınırlar.
Retry:	Hata alan işlemleri otomatik olarak yeniden denemeyi sağlar.
Bulkhead: Kaynak izolasyonu sağlar. Bir servisteki yoğunluk diğerini etkilemez.
TimeLimiter: Maksimum çalıştırma süresi belirler, süresi dolan çağrılar iptal edilir.
Cache: Yanıtları önbelleğe alarak tekrar hesaplamayı engeller.

🧠 Örnek Senaryo: Circuit Breaker
-Bir mikroservis başka bir servise çağrı yapıyor ve karşı servis sık sık hata veriyorsa:

*İlk başta Resilience4j bu hataları kaydeder.
*Belirli bir eşik aşıldığında, circuit "open" hale gelir ve çağrılar hemen kesilir.
*Bir süre sonra sistem tekrar "half-open" moda geçer, test çağrıları yapılır.
*Eğer servis iyileştiyse tekrar "closed" moda döner.


Implementing Circuit Breaker pattern in Gateway;

- gatewayserver projesinde pom.xml dosyasına aşağıdaki bağımlılığı ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
</dependency>

- GatewayserverApplication sınıfında "accounts" router ına ".circuitBreaker(config -> config.setName("accountsCircuitBreaker")))" config i ekliyoruz.

.route(p -> p
	.path("/meryilbank/accounts/**")
	.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.circuitBreaker(config -> config.setName("accountsCircuitBreaker")))
	.uri("lb://ACCOUNTS")) // eureka serverdaki mikroservis adı ne ise o olacak

- Daha sonra gatewayserver application.yml dosyasına circuitbreaker configürasyonunu ekliyoruz.

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

- Postman den circuit breakers durumunu kontrol edebilirsin:

http://localhost:8072/actuator/circuitbreakers
http://localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker

Send callback to customer;
- Hata oluştuğunda kullanıcıya hata ile ilgili geri dönüş yapmak için gatewayserver a "FallbackController" sınıfı ekliyoruz. Burada support team e hata maili vb. gönderebiliriz istersek.

@RestController
public class FallbackController {

    @RequestMapping("/contactSupport")
    public Mono<String> contactSupport() {
        // you can send the email which inside an error to support team
        return Mono.just("An error occurred. Please try after some time or contact support team!!!");
    }
}

- GatewayserverApplication da accounts router ına ".setFallbackUri("forward:/contactSupport")" fallback uri ekliyoruz.

.route(p -> p
	.path("/meryilbank/accounts/**")
	.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.circuitBreaker(config -> config.setName("accountsCircuitBreaker")
					.setFallbackUri("forward:/contactSupport")))


Implementing Circuit Breaker pattern with FeignClient;

- Accounts mikroservisinde aşağıdaki bağımlılığı ekliyoruz:

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>

- Daha sonra "application.yml" dosyasına aşağıdaki konfigürasyonu ekliyoruz:

spring:
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true

- circuirbreaker konfigürasyonunu da ekliyoruz:

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

Circuitbreaker for Feign Clients;

- Account mikroservisinde service.client paketi altına "CardsFallback" ve "LoansFallback"  sınıflarını ekliyoruz:

@Component
public class CardsFallback implements CardsFeignClient{

    @Override
    public ResponseEntity<CardsDto> fetchCardDetails(String correlationId, String mobileNumber) {
        //buraya card mikroservisi hata alması durumunda yapmak istediklerini yazabilirsin
        return null;
    }
}

@Component
public class LoansFallback implements LoansFeignClient {

    @Override
    public ResponseEntity<LoansDto> fetchLoanDetails(String correlationId, String mobileNumber) {
        return null;
    }
}

- "CardsFeignClient" ve "LoansFeignClient" interfacelerine ise @FeignClient anatasyonuna fallback parametresi ekle.

@FeignClient(name="cards",fallback = CardsFallback.class)
@FeignClient(name="loans",fallback = LoansFallback.class)

- "CustomerServiceImpl" sınıfında "CardsFeignClient" ve "LoansFeignClient" sınıflarını çağırdığımız yerde null check kontrolü ekliyoruz.


HTTP TIMEOUT CONFIGURATIONS;

- Tüm mikroservisler için gateway servisinin application.yml dosyasına timeout konfigürasyonlarını ekliyoruz. Eklemezsek 30 sn servisin cevap vermesini bekleriz. Eğer "GatewayserverApplication" sınıfında özel circuitBreaker konfigürasyonu eklemezsek router kısmında bu genel timeout süreleri geçerli olur.

spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
        

🔧 Retry Pattern Nedir?
Bir işlem (örneğin bir HTTP isteği, veritabanı çağrısı, uzak servis iletişimi) başarısız olduğunda, hemen hata döndürmek yerine belirli bir süre ve sayı kadar tekrar denenmesidir.

📌 Ne zaman kullanılır?
Geçici ağ sorunları

-Anlık yoğunluk nedeniyle başarısız olan istekler
-Dış sistemin kısa süreli erişilemez durumda olması
-Timeout’lar veya HTTP 5xx hataları gibi durumlar

Implementing Retry pattern in Gateway;

- Gateway mikroservisinde GatewayserverApplication sınıfında loans mikroservis router ına retry konfigürasyonlarını ekliyoruz.

.route(p -> p
	.path("/meryilbank/loans/**")
	.filters( f -> f.rewritePath("/meryilbank/loans/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.retry(retryConfig -> retryConfig.setRetries(3)
					.setMethods(HttpMethod.GET)
					.setBackoff(Duration.ofMillis(100),Duration.ofMillis(1000),2,true)))
	.uri("lb://LOANS"))


Implementing Retry pattern in accounts microservice;

- AccountsController a konfgürasyon eklemek istediğimiz apiye @Retry anatasyonunu ve ilgili fallback metodunu ekliyoruz.

 @Retry(name = "getBuildInfo",fallbackMethod = "getBuildInfoFallback")
    @GetMapping("/build-info")
    public ResponseEntity<String> getBuildInfo() {
        return ResponseEntity.status(HttpStatus.OK).body(buildVersion);
    }

    public ResponseEntity<String> getBuildInfoFallback(Throwable throwable) {
        logger.debug("getBuildInfoFallback() method Invoked");
        return ResponseEntity
                .status(HttpStatus.OK)
                .body("0.9");
    }
    
- Gateway mikroservisine yukarıda tanımladığımız retry fallback i için aşağıdaki konfigürasyon fonksiyonunu "GatewayserverApplication" sınıfına tanımlıyoruz. İlgili apiye istek atıp denemeler sonucu hala hata alırsak getBuildInfoFallback fonksiyonunda tanımladığımız "0.9" yanıtını cevap olarak alırız.

@Bean
public Customizer<ReactiveResilience4JCircuitBreakerFactory> defaultCustomizer() {
	return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
			.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
			.timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(4)).build()).build());
	}
	

- Postmandan istek attığımızda retry pattern i uyguladığımız için response header kısmında istek atılan kadar correlation id bulunuyordu. Bunu önlemek için gateway server da "ResponseTraceFilter" sınıfında "postGlobalFilter" fonksiyonuna aşağıdaki koşulu ekliyoruz.

  if(!(exchange.getResponse().getHeaders().containsKey(filterUtility.CORRELATION_ID))) {
    logger.debug("Updated the correlation id to the outbound headers: {}", correlationId);
    exchange.getResponse().getHeaders().add(filterUtility.CORRELATION_ID, correlationId);
}


Rate Limitter Pattern;

Rate Limiter Pattern (Hız Sınırlama Deseni), bir sistemin belirli bir zaman aralığında alabileceği maksimum istek (request) sayısını sınırlandıran bir yük yönetim (throttling) desenidir.

🔧 Rate Limiter Pattern Nedir?
- Bir servis ya da sistem belirli bir trafik limitine sahiptir. Bu desende:
- Belirlenen sınır aşılırsa, gelen istekler geçici olarak engellenir veya hata döner.
- Sistem böylece çökmekten korunur, kaynaklar tükenmez ve adil kullanım sağlanır.

📌 Ne zaman kullanılır?
- DDOS gibi aşırı yük durumlarına karşı koruma
- Ortak kullanılan (shared) servislerin adil paylaşımı
- API’lerin aşırı tüketilmesini engellemek
- Mikroservisler arası çağrılarda geri basınç (back pressure) oluşturmak için

Implementing Rate Limitter pattern in Gateway Server;

- pom.xml e aşağıdaki bağımlılığı ekliyoruz.

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>


- "GatewayserverApplication" sınıfına aşağıdaki iki bean i ekliyoruz.

@Bean
public RedisRateLimiter redisRateLimiter() {
	return new RedisRateLimiter(1, 1, 1);
}

@Bean
KeyResolver userKeyResolver() {
	return exchange -> Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst("user"))
			.defaultIfEmpty("anonymous");
}

- "GatewayserverApplication" sınıfında cards router ına requestRateLimiter config ini ekliyoruz.

.route(p -> p
	.path("/meryilbank/cards/**")
	.filters( f -> f.rewritePath("/meryilbank/cards/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.requestRateLimiter(config -> config.setRateLimiter(redisRateLimiter())
					.setKeyResolver(userKeyResolver())))
	.uri("lb://CARDS")).build();
	

- application.yml a aşağıdaki konfigürasyonu ekliyoruz.

spring:
  data:
    redis:
      connect-timeout: 2s
      host: localhost
      port: 6379
      timeout: 1s
       
Implementing Rate Limitter pattern in accounts microservice;

- AccountsController ında getJavaVersion fonksiyonuna rate limitter ı uyguluyoruz aşağıdaki gibi;

@RateLimiter(name= "getJavaVersion", fallbackMethod = "getJavaVersionFallback")
@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
return ResponseEntity.status(HttpStatus.OK).body(environment.getProperty("JAVA_HOME"));
}

public ResponseEntity<String> getJavaVersionFallback(Throwable throwable) {
return ResponseEntity
        .status(HttpStatus.OK)
        .body("Java 21");
}


- application.yml a aşağıdaki konfigürasyonu ekliyoruz.
      
resilience4j.ratelimiter:
  configs:
    default:
      timeoutDuration: 1000
      limitRefreshPeriod: 5000
      limitForPeriod: 1
  
NOTE;
- Docker da redis servisi ayağa kaldırıyoruz.


Rate Limitter Pattern Testi için Apache Benchmark kullanıyoruz;

Kurulum;
sudo apt update
sudo apt install apache2-utils

- Aşağıdaki komut ile terminal ekranından istek atıyoruz;
ab -n 10 -c 2 -v 3 http://localhost:8072/meryilbank/cards/api/contact-info

Apache Benchmark (ab) Nedir?

-Apache Benchmark (ab), web uygulamanızın performansını test etmek için kullanılan hafif ve basit bir yük testi aracıdır. Genellikle bir web sunucusunun veya REST API'nin eşzamanlı istekleri nasıl karşıladığını ölçmek için kullanılır.

🔧 Ne İşe Yarar?
Apache Benchmark şu sorulara yanıt verir:

- Sunucum saniyede kaç isteği karşılayabiliyor?
- Yüksek trafikte sistem ne kadar dayanıklı?
- Ortalama yanıt süresi ne kadar?
- Eş zamanlı bağlantılarda performans düşüyor mu?

📘 Temel Komut;
ab -n 1000 -c 10 http://localhost:8080/endpoint

Anlamı:
-n 1000: Toplam 1000 istek gönder.
-c 10: Aynı anda 10 isteği paralel gönder.
URL: Test etmek istediğin endpoint.


Bulkhead Pattern Nedir?
      
Bulkhead Pattern (Bölme Deseni), bir uygulamada sistem kaynaklarını izole ederek, bir bileşenin çökmesinin diğer bileşenleri etkilemesini önleyen bir hata toleransı desenidir.

🧱 1. Bulkhead Pattern Nedir?
Bu desenin adı, gemi mühendisliğinden gelir:
Gemilerde bölmeler (bulkhead) kullanılarak bir bölüm su alırsa diğer bölümler etkilenmesin diye izolasyon sağlanır.

Yazılımda da aynı şekilde:
Bir servis veya iş parçası aşırı yük altına girerse, diğer servislerin de çökmesini engellemek için izole edilir.

🎯 2. Ne Zaman Kullanılır?
- Mikroservis mimarisinde servislerin birbirinden etkilenmemesi isteniyorsa
- Yoğun yük altında bir bileşenin diğer işlevleri bloke etmesini istemiyorsan
- Bir sistemde farklı önem derecesine sahip işlemler varsa (örneğin kritik vs arka plan işlemleri)






