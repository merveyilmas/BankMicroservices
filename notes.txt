Springboot;
@RestController -> Rest apiler iÃ§in kullanÄ±lÄ±r
@Controller -> MVC projeler iÃ§in kullanÄ±lÄ±r


Maven Commands;
- mvn clean install
- mvn spring-boot:run

- java -jar target/accounts-0.0.1-SNAPSHOT.jar


Docker Commands;
- docker build . -t merveyilmas/accounts:s4
(dockerfile olan dizinde dockerfile dan image oluÅŸturur)
- docker images
(docker image leri listeler)
- docker inspect image 6121
(image id ye gÃ¶re image bilgilerini listeler)

- terminalden docker desktop a login olmak iÃ§in; docker login -u merveyilmas

- docker run -p 8080:8080 merveyilmas/accounts:s4 
(image Ä± container iÃ§inde Ã§alÄ±ÅŸtÄ±rÄ±r)
- docker run -d -p 8080:8080 merveyilmas/accounts:s4
(-d ile "detech" container Ä± arka planda Ã§alÄ±ÅŸtÄ±rÄ±rÄ±z)
(dÄ±ÅŸarÄ±ya aÃ§Ä±lan docker port : container iÃ§erisindeki proje Ã§alÄ±ÅŸma portu)
- docker ps
(Ã§alÄ±ÅŸan conatiner larÄ± listeler)
- docker ps -a
(tÃ¼m container larÄ± listeler)
- docker start e0443edcb6ac0541e8ff46d1aa221660f755985d78ddc904ae50d7bc0c998a65
(conatiner Ä±d ile container Ã§alÄ±ÅŸtÄ±rÄ±r)


Accounts Dockerfile Ã¶rneÄŸi;

#Start with a base image containing Java runtime
FROM openjdk:21-jdk-slim

# MAINTAINER instruction is deprecated in favor of using label
# MAINTAINER meryil.com
#Information around who maintains the image
LABEL "org.opencontainers.image.authors"="meryil.com"

# Add the application's jar to the image
COPY target/accounts-0.0.1-SNAPSHOT.jar accounts-0.0.1-SNAPSHOT.jar

# execute the application
ENTRYPOINT ["java", "-jar", "accounts-0.0.1-SNAPSHOT.jar"]


- Dockerfile oluÅŸturmak iÃ§in buildpacks ve GoogleJib kullanabiliriz.


BUILDPACKS:

Dockerfile olmadan buildpacks ile image oluÅŸturmak iÃ§in;

1. Packaging yÃ¶ntemini ekle:
<version>0.0.1-SNAPSHOT</version>
<packaging>jar</packaging>

2. Image name i ekle:
<configuration>
	<image>
		<name>merveyilmas/${project.artifactId}:s4</name>
	</image>
	<excludes>
		<exclude>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</exclude>
	</excludes>
</configuration>

- <packaging> ve <image> i ilgili yerlere ekle pom.xml de
- mvn spring-boot:build-image
(maven ile image oluÅŸturmak iÃ§in bu komutu Ã§alÄ±ÅŸtÄ±rdÄ±k)


GOOGLE JIB:

- Jib works only java applications.

1. Google jib plugin i pom.xmle e ekle.

<plugin>
<groupId>com.google.cloud.tools</groupId>
<artifactId>jib-maven-plugin</artifactId>
<version>3.4.4</version>
<configuration>
  <to>
    <image>merveyilmas/${project.artifactId}:s4</image>
  </to>
</configuration>
</plugin> 

2. mvn compile jib:dockerBuild
(google jib ile image oluÅŸturduk)

- mvn compile jib:build
( Bu komut ile sistemde docker yÃ¼klÃ¼ olmasa bile goggle jib ile image oluÅŸturabiliriz.)


Push image to DockerHub;
- docker image push docker.io/merveyilmas/accounts:s4

Pull image to DockerHub;
- docker image pull merveyilmas/accounts:s4


Docker Compose;

- Docker Compose, birden fazla Docker konteynerini tanÄ±mlamak ve yÃ¶netmek iÃ§in kullanÄ±lan bir araÃ§tÄ±r. Genellikle mikro hizmet mimarileri ve Ã§oklu konteyner uygulamalarÄ± geliÅŸtirenler tarafÄ±ndan kullanÄ±lÄ±r. Docker Compose, bir YAML dosyasÄ±na (docker-compose.yml) servisleri, aÄŸlarÄ±, hacimleri ve konteyner ayarlarÄ±nÄ± tanÄ±mlamanÄ±za olanak tanÄ±r.

- docker compose version

- Docker compose dosyasÄ±nÄ± istediÄŸimiz dizinde oluÅŸturabiliriz. Dosya ismi docker-compose.yml olmalÄ±dÄ±r.

- docker compose up -d
(docker compose dosyasÄ±nÄ± oluÅŸturduÄŸumuz yerde bu komut ile container larÄ± oluÅŸturup, microservisleri Ã§alÄ±ÅŸtÄ±rabiliriz)

- docker compose stop
(tÃ¼m containerlarÄ± durdurur, silmez)

- docker compose down
(tÃ¼m containerlerÄ± siler)


CLOUD NATIVE APPLICATIONS;

- Cloud-native applications (bulut yerel uygulamalar), bulut ortamlarÄ±nda Ã§alÄ±ÅŸacak ÅŸekilde tasarlanmÄ±ÅŸ ve geliÅŸtirilmiÅŸ uygulamalardÄ±r. Bu tÃ¼r uygulamalar, bulutun sunduÄŸu avantajlardan tam olarak faydalanacak ÅŸekilde yapÄ±landÄ±rÄ±lÄ±r ve genellikle mikro hizmet mimarisi, konteynerler, otomatik Ã¶lÃ§ekleme, sÃ¼rekli entegrasyon/sÃ¼rekli daÄŸÄ±tÄ±m (CI/CD) gibi modern yazÄ±lÄ±m geliÅŸtirme yaklaÅŸÄ±mlarÄ±nÄ± kullanÄ±r.

- Ã–rnek Teknolojiler: 
Kubernetes: Konteynerlerin orkestrasyonu.
Docker: Konteyner teknolojisi.
Prometheus: Ä°zleme ve uyarÄ± sistemi.
Istio: Servis aÄŸÄ± ve mikro hizmetler iÃ§in bir yÃ¶netim platformu.
Terraform: AltyapÄ± otomasyonu.


12-Factor App ve 15-Factor App Metodolojileri;

- 12-Factor App ve 15-Factor App metodolojileri, bulut tabanlÄ± uygulamalarÄ±n geliÅŸtirilmesi ve daÄŸÄ±tÄ±lmasÄ± iÃ§in uygulama geliÅŸtirme sÃ¼reÃ§lerinde en iyi uygulamalarÄ± tanÄ±mlar. Bu metodolojiler, modern, mikro hizmet tabanlÄ± uygulamalarÄ±n esnek, taÅŸÄ±nabilir ve sÃ¼rdÃ¼rÃ¼lebilir olmasÄ±nÄ± saÄŸlamak iÃ§in Ã§eÅŸitli yÃ¶nergeler sunar.

12-Factor App Metodolojisi;

- 12-Factor App metodolojisi, her bir uygulamanÄ±n bulut ortamÄ±nda verimli Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayacak ÅŸekilde geliÅŸtirilmesi iÃ§in 12 temel prensipten oluÅŸur. Bu prensipler, uygulamanÄ±n taÅŸÄ±nabilirliÄŸini, esnekliÄŸini ve Ã¶lÃ§eklenebilirliÄŸini arttÄ±rmaya yÃ¶nelik ipuÃ§larÄ± sunar. 12-Factor, Ã¶zellikle bulut yerel (cloud-native) uygulamalar iÃ§in Ã¶nemli bir rehberdir.

12-Factor Uygulama Prensipleri:

1. Codebase (Kod TabanÄ±): Uygulama, tek bir kod tabanÄ±ndan (repository) yÃ¶netilmelidir ve her ortamda (geliÅŸtirme, test, Ã¼retim) aynÄ± kod tabanÄ± kullanÄ±lmalÄ±dÄ±r.

2. Dependencies (BaÄŸÄ±mlÄ±lÄ±klar): UygulamanÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ± aÃ§Ä±kÃ§a tanÄ±mlanmalÄ± ve baÄŸÄ±msÄ±z olarak yÃ¼klenebilmelidir. Yani, uygulama baÄŸÄ±mlÄ±lÄ±klarÄ± dÄ±ÅŸarÄ±dan (Ã¶rneÄŸin, package.json, pom.xml) aÃ§Ä±kÃ§a belirtmelidir.

3. Config (YapÄ±landÄ±rma): YapÄ±landÄ±rma verileri (veritabanÄ± baÄŸlantÄ± bilgileri gibi), uygulamanÄ±n iÃ§inde deÄŸil, dÄ±ÅŸ bir ortamda veya Ã§evresel deÄŸiÅŸkenlerde saklanmalÄ±dÄ±r.

4. Backing Services (Destekleyici Servisler): VeritabanlarÄ±, mesajlaÅŸma sistemleri gibi dÄ±ÅŸ servisler, uygulamanÄ±n bir parÃ§asÄ± gibi dÃ¼ÅŸÃ¼nÃ¼lmeli, fakat ayrÄ± birer servis olarak ele alÄ±nmalÄ±dÄ±r.

5. Build, Release, Run (YapÄ±, YayÄ±nlama, Ã‡alÄ±ÅŸtÄ±rma): UygulamanÄ±n derlenmesi (build), yayÄ±na alÄ±nmasÄ± (release) ve Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± (run) sÃ¼reÃ§leri ayrÄ±lmalÄ±dÄ±r. Her aÅŸama aÃ§Ä±kÃ§a tanÄ±mlanmalÄ±dÄ±r.

6. Processes (Ä°ÅŸlemler): Uygulama, durumu taÅŸÄ±mayan (stateless) iÅŸlemlerle Ã§alÄ±ÅŸmalÄ±dÄ±r. Her iÅŸlem kendi baÅŸÄ±na baÄŸÄ±msÄ±z olmalÄ± ve iÅŸlem sÄ±rasÄ±ndaki herhangi bir kayÄ±p, diÄŸer iÅŸlemleri etkilememelidir.

7. Port Binding (Port BaÄŸlama): Uygulama, bir web sunucusunu Ã§alÄ±ÅŸtÄ±rmak iÃ§in bir port Ã¼zerinden eriÅŸilebilir olmalÄ±dÄ±r. Uygulama dÄ±ÅŸÄ±ndaki proxy sistemleri yerine, uygulamanÄ±n kendisi doÄŸrudan HTTP veya TCP portu Ã¼zerinden dinlemelidir.

8. Concurrency (EÅŸzamanlÄ±lÄ±k): Uygulama, artan talepleri karÅŸÄ±lamak iÃ§in Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ± (concurrency) veya iÅŸlemlerle yatay olarak Ã¶lÃ§eklenebilir olmalÄ±dÄ±r.

9. Disposability (GeÃ§ici Olma): Uygulama, kÄ±sa sÃ¼reli yaÅŸam dÃ¶ngÃ¼lerine sahip olmalÄ± ve gerektiÄŸinde hÄ±zlÄ±ca baÅŸlatÄ±labilir ve sonlandÄ±rÄ±labilir olmalÄ±dÄ±r.

10. Dev/Prod Parity (GeliÅŸtirme ve Ãœretim FarkÄ±): GeliÅŸtirme, test ve Ã¼retim ortamlarÄ± arasÄ±ndaki farklar minimumda tutulmalÄ±dÄ±r. GeliÅŸtiriciler ve operasyon ekipleri arasÄ±ndaki kopukluk azaltÄ±lmalÄ±dÄ±r.

11. Logs (Loglar): Uygulama, log verilerini stdout (standart Ã§Ä±ktÄ±) Ã¼zerinden dÄ±ÅŸarÄ±ya gÃ¶ndermeli ve bu loglar merkezi bir sistemde toplanmalÄ±dÄ±r.

12. Admin Processes (YÃ¶netici Ä°ÅŸlemleri): YÃ¶netici ve bakÄ±m iÅŸlemleri (Ã¶rneÄŸin, veritabanÄ± migration'larÄ±) uygulamanÄ±n bir parÃ§asÄ± olarak tanÄ±mlanmalÄ± ve Ã§alÄ±ÅŸtÄ±rÄ±labilir olmalÄ±dÄ±r.

15-Factor App Metodolojisi;

- 15-Factor App metodolojisi, 12-Factor App metodolojisinin bir uzantÄ±sÄ±dÄ±r ve 12-Factor'a ek olarak bazÄ± ekstra faktÃ¶rler ekler. Bu faktÃ¶rler, bulut tabanlÄ± uygulamalarÄ±n daha etkili bir ÅŸekilde yÃ¶netilmesi, izlenmesi ve yapÄ±landÄ±rÄ±lmasÄ±na olanak saÄŸlar.

15-Factor Uygulama Prensipleri:

- 15-Factor App, 12-Factor metodolojisinin temeline dayanarak daha detaylÄ± bir yapÄ± saÄŸlar. Ekstra faktÃ¶rler ÅŸunlardÄ±r:

13. Rate Limiting (HÄ±z Limitleme): Uygulama, dÄ±ÅŸarÄ±ya aÃ§Ä±lan API'lar ve servislerle olan etkileÅŸimlerde hÄ±z sÄ±nÄ±rlamasÄ± yapabilmelidir. Bu, istek baÅŸÄ±na alÄ±nabilecek yanÄ±t sayÄ±sÄ±nÄ± sÄ±nÄ±rlayarak uygulamanÄ±n aÅŸÄ±rÄ± yÃ¼klenmesini engeller.

14. Backups (Yedekleme): VeritabanÄ± ve diÄŸer kritik servisler iÃ§in dÃ¼zenli yedekleme stratejileri tanÄ±mlanmalÄ±dÄ±r. Bu, felaket durumlarÄ±nda veri kaybÄ±nÄ± Ã¶nler.

15. Health Checks (SaÄŸlÄ±k Kontrolleri): Uygulama, Ã§alÄ±ÅŸma durumunu dÃ¼zenli olarak kontrol edebilecek saÄŸlÄ±k kontrolÃ¼ mekanizmalarÄ±na sahip olmalÄ±dÄ±r. Bu sayede sistem hatalarÄ±na karÅŸÄ± otomatik olarak yanÄ±t verilebilir.

12-Factor ve 15-Factor KarÅŸÄ±laÅŸtÄ±rmasÄ±;

- 12-Factor App metodolojisi, bulut ortamlarÄ±nda verimli Ã§alÄ±ÅŸan ve sÃ¼rdÃ¼rÃ¼lebilir uygulamalar geliÅŸtirmek iÃ§in temel yÃ¶nergeleri saÄŸlar.
15-Factor App metodolojisi, 12-Factor metodolojisini geniÅŸleterek uygulama yÃ¶netimi ve izleme gibi ekstra faktÃ¶rler ekler. Bu, bÃ¼yÃ¼k Ã¶lÃ§ekli sistemlerde daha iyi bir operasyonel yÃ¶netim saÄŸlar.


CONGIFURATION MANAGEMENT IN MICROSERVICE;

Read properties in Springboot app:

1. Using @Value annotation; 

application.yml veya application.properties dosyasÄ±na tanÄ±mladÄ±ÄŸÄ±mÄ±z deÄŸiÅŸkenlere istediÄŸimiz yerde eriÅŸebiliriz.

Ã–R;
application.yml;

build:
  version: "1.0"
  
account controller;

@Value("${build.version}")
private String buildVersion;

2. Using Environment;

- Ã‡evresel deÄŸiÅŸkenlere eriÅŸmek iÃ§in kullanÄ±rÄ±z.

Ã–R;

account controller;

@Autowired
private Environment environment;

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
	return ResponseEntity.status(HttpStatus.OK).body(environment.getProperty("JAVA_HOME"));
}

AÃ§Ä±klama;
// jdk nÄ±n yÃ¼klÃ¼ olduÄŸu dizini verir
environment.getProperty("JAVA_HOME")

// maven Ä±n yÃ¼klÃ¼ olduÄŸu dizini verir
environment.getProperty("MAVEN_HOME")

3. Using @ConfigurationProperties;

-Birden fazla deÄŸiÅŸkene deÄŸer tanÄ±mlamak iÃ§in kullanabiliriz.

Ã–R;

application.yml;

accounts:
  message: "Welcome to EazyBank accounts related local APIs "
  contactDetails:
    name: "John Doe - Developer"
    email: "john@eazybank.com"
  onCallSupport:
    - (555) 555-1234
    - (555) 523-1345

AccountsContactInfoDto;

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {
}

AccountsApplication;

@SpringBootApplication
@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})

AccountsController;

@Autowired
private AccountsContactInfoDto accountsContactInfoDto;

@GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo() {
        return ResponseEntity.status(HttpStatus.OK).body(accountsContactInfoDto);
    }
    
Springboot Profiles;

- application_prod.yml ve application_qa.yml isminde iki ayrÄ± profil oluÅŸturduk.

application_qa.yml;

spring:
  config:
    activate:
      on-profile: "qa"

build:
  version: "2.0"

accounts:
  message: "Welcome to Meryil accounts related QA APIs "
  contactDetails:
    name: "Smitha Ray - QA Lead"
    email: "smitha@meryil.com"
  onCallSupport:
    - (666) 265-3765
    - (666) 734-8371

application.yml;

spring:
  config:
    import:
      - "application_qa.yml"
      - "application_prod.yml"
  profiles:
    active:
      - "qa"
      
- application.yml dosyasÄ±nda profiles.active kÄ±smÄ±nda hangi profile in ismini yazarsak o yml dosyasÄ±ndaki konfigÃ¼rasyonlar Ã§alÄ±ÅŸÄ±r.


Komut SatÄ±rÄ± ile Profile Aktif Etme;

1. Program arguments ile set etme;

- Intellij idea Ã¼zerinden profili aktif etmek iÃ§in AccountsApplictaion dosyasÄ±na saÄŸ tÄ±k yapÄ±p, more run/debug - modify run configuration e tÄ±klarÄ±z. ArdÄ±ndan aÃ§Ä±lan pencerede program arguments kÄ±smÄ±na 

--spring.profiles.active=prod  --build.version=1.1 

ÅŸeklinde yazarak istediÄŸimiz deÄŸiÅŸkeni set ederiz.

2. VM options ile set etme;

- Intellij idea Ã¼zerinden profili aktif etmek iÃ§in AccountsApplictaion dosyasÄ±na saÄŸ tÄ±k yapÄ±p, more run/debug - modify run configuration e tÄ±klarÄ±z. ArdÄ±ndan aÃ§Ä±lan pencerede modify options kÄ±smÄ±ndan 'Add VM options' seÃ§eneÄŸine tÄ±klarÄ±z. AÃ§Ä±lan sekmeye ise 

-Dspring.profiles.active=prod  -Dbuild.version=1.1

ÅŸeklinde yazarak istediÄŸimiz jvm deÄŸiÅŸkenlerini set ederiz.

3. Environment Variables ile set etme;

- Intellij idea Ã¼zerinden profili aktif etmek iÃ§in AccountsApplictaion dosyasÄ±na saÄŸ tÄ±k yapÄ±p, more run/debug - modify run configuration e tÄ±klarÄ±z. ArdÄ±ndan aÃ§Ä±lan pencerede environment variable kÄ±smÄ±na

SPRING_PROFILES_ACTIVE=prod;BUILD_VERSION=1.8;

ÅŸeklinde yazarak istediÄŸimiz deÄŸiÅŸkenlerini set ederiz.

- EÄŸer konfigÃ¼rasyon dosyasÄ±nda 3 alana da deÄŸiÅŸkenleri set edersek proje program arguments kÄ±smÄ±nda yazan deÄŸeri alÄ±r. 

- EÄŸer VM ve environment kÄ±smÄ±nda aynÄ± aynda deÄŸiÅŸken set edilirse VM variable kÄ±smmÄ±ndaki deÄŸiÅŸkeni baz alÄ±r.

- Yani Ã¶ncelik sÄ±rasÄ±;
Program arguments > VM options > Environment Variables


SPRING CLOUD CONFIG;

- Spring initializers dan spring config projesi oluÅŸturduk.
Proje oluÅŸtururken dependency olarak "config server" ve "spring boot actuator" baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± seÃ§tik.

1. Reading configurations from the class path location of config server;

- Config server projesinde "resources" dizini altÄ±na "config" klasÃ¶rÃ¼ ekledik. Config klasÃ¶rÃ¼ altÄ±na ise tÃ¼m yml dosyalarÄ±nÄ± taÅŸÄ±dÄ±k. (accounts.yml, accounts-prod.yml vs.) Serverconfig projesine aÅŸaÄŸÄ±daki linkler ile istek atarak tanÄ±mlanan configÃ¼rasyonlara eriÅŸim saÄŸlarÄ±z.

- http://localhost:8071/accounts/default
- http://localhost:8071/accounts/prod
- http://localhost:8071/accounts/qa
- http://localhost:8071/loans/qa

- Config server a accounts, cards ve loans yml dosyalarÄ± eklendikten sonra accounts, cards ve loans projelerindeki prod ve qa konfigÃ¼rasyonlarÄ±nÄ± siliyoruz.

- Accounts projesine config client dependency lerini ekliyoruz.

<properties>
	<java.version>21</java.version>
	<spring-cloud.version>2024.0.0</spring-cloud.version>
</properties>
	
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-config</artifactId>
</dependency>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>${spring-cloud.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>


- accounts projesindeki application.yml dosyasÄ±nÄ±n son hali bu ÅŸekilde oluyor;

spring:
  application:
    name: accounts
  profiles:
    active: "prod"
  datasource:
    url: jdbc:mysql://localhost:3306/UdemyAccounts
    username: merve
    password: Merve123.
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      javax:
        persistence:
          validation:
            mode: none
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
  config:
    import: "optional:configserver:http://localhost:8071/"

application:
  version: 1.0.0

server:
  port: 8080

logging:
  level:
    org.springframework: error

---
application:
    name: accounts
---
- Bu kÄ±sÄ±mdaki name alanÄ± configserver projesinde accounts projesi iÃ§in oluÅŸturulan yml dosyasÄ±nÄ±n ismi ile aynÄ± olmak zorunda.

- AynÄ± iÅŸlemleri lonas ve cards projeleri iÃ§in de yapÄ±yoruz.

2. Reading configurations from a file system location;
- configserver projesindeki konfigÃ¼rasyonlarÄ± barÄ±ndÄ±ran config dosyasÄ±nÄ± kopyalayÄ±p bilgisayarada bir dizine yapÄ±ÅŸtÄ±rdÄ±m. ("/home/merveyilmaz/Documents/config")

- Daha sonra ise configserver projesinde bulunan application.yml dosyasÄ±ndaki config.server.native.search.locations kÄ±smÄ±nÄ± dosya yolu olacak ÅŸekilde dÃ¼zenliyoruz.

spring:
  application:
    name: "configserver"
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          #search-locations: "classpath:/config"
          search-locations: "file:///home/merveyilmaz/Documents/config"

3. Reading configurations from a github repository;

- github da public repository aÃ§Ä±p config klasÃ¶rÃ¼ altÄ±ndaki yml dosyalarÄ±nÄ± bu repository e pushluyoruz. ArdÄ±ndan configserver projesi altÄ±ndaki application.yml dosyasÄ±nda aÅŸaÄŸÄ±daki dÃ¼zenlemeleri yapÄ±yoruz.

spring:
  application:
    name: "configserver"
  profiles:
    #active: native
    active: git
  cloud:
    config:
      server:
        #native:
          #search-locations: "classpath:/config"
          #search-locations: "file:///home/merveyilmaz/Documents/config"
        git:
          uri: "https://github.com/eazybytes/eazybytes-config.git"
          default-label: main
          timeout: 5
          clone-on-start: true
          force-pull: true

server:
  port: 8071


Encryption & Decryption of properties inside config server;

- config dosyamÄ±zÄ± github a yÃ¼klediÄŸimiz iÃ§in verilerimizi gÃ¶stermek istemeyiz. Config verilerini ÅŸifrelemek iÃ§in configserver projesindeki application.yml dosyasÄ±na ÅŸu alanÄ± ekleriz.

encrypt:
  key: "45D81EC1EF61DF9AD8D3E5BB397F9"

bu bizim ÅŸifreleme keyimiz olur.

http://localhost:8071/encrypt 
(body e ÅŸifrelemek istediÄŸin text i koy body-raw-text)
http://localhost:8071/decrypt 
(body e config verisinin ÅŸifrelenmiÅŸ halini koy)

apileri ile ÅŸifreleme veya ÅŸifrelenmiÅŸ veriyi Ã¶ÄŸrenme iÅŸlemlerini gerÃ§ekleÅŸtirebiliriz.

- En son olarak ise ÅŸifrelemek istediÄŸimiz veriyi ÅŸifreledikten sonra github da ilgili yere "{cipher}ÅŸifrelenmiÅŸveri" ÅŸeklinde gÃ¼ncelleriz.


Refresh configurations at runtime using REFRESH ACTUATOR PATH;

- Config dosyasÄ±nda herhangi bir deÄŸiÅŸiklik yapÄ±ldÄ±ÄŸÄ±nda projemiz otomatik algÄ±lasÄ±n istiyoruz.

- Mikroservislerin pom.xml dosyamÄ±zda actuator dependency i olmasÄ± gerekir.

- Mikroservislerin ContactDto sÄ±nÄ±flarÄ±nÄ± record dan normal class a dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼k ki run time da herhangi bir deÄŸiÅŸiklik algÄ±landÄ±ÄŸÄ±nda deÄŸiÅŸkenler deÄŸiÅŸikliÄŸi alÄ±gÄ±layabilsin. 

@ConfigurationProperties(prefix = "loans")
@Getter @Setter
public class LoansContactInfoDto {

    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}

- Mikroservislerin application.yml dosyalarÄ±na ÅŸu konfigÃ¼rasyonu ekliyoruz;

management:
  endpoints:
    web:
      exposure:
        include: "*"

- Githubdan accounts-prod.yml dosyasÄ±nda bir string i deÄŸiÅŸtirdiÄŸÄŸimizde projeyi yeniden baÅŸlatmaya gerek kalmadan configÃ¼rasyon dosyasÄ± proje tarafÄ±ndan otomatik algÄ±lanÄ±r. Githubdan string deÄŸiÅŸtirip config serverdan http://localhost:8071/accounts/prod adresine istek atarak test edebiliriz.

- Bu iÅŸlem actuator sayesinde olur.

- localhost:8080/actuator adresine istek atarak actuator Ä±n sunduÄŸu apileri gÃ¶rebiliriz.

- localhost:8080/actuator/refresh endpointi ile hangi property lerin deÄŸiÅŸtiÄŸini gÃ¶rebiliriz.


Refresh configurations at runtime using Spring Cloud Bus;

- Spring cloud bus konfigÃ¼rasyon dosyasÄ±nd aherhangi bir deÄŸiÅŸiklik olduÄŸunda kaÃ§ adet mikroservis var ise hepsine aynÄ± anda mesaj gÃ¶nderir.

- Bunu rabbit mq ile yapacaÄŸÄ±z.
- TÃ¼m mikroservis projelerimize ve configserver projemize aÅŸaÄŸÄ±daki dependency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>

- Rabbitmq yu bilgisayarÄ±mÄ±za docker komutu ile kuruyoruz
(# latest RabbitMQ 4.0.x
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management) - rabbit mq sitesinde var

- Daha sonra tÃ¼m mikroservislerdeki application.yml dosyasÄ±na rabbit mq konfigÃ¼rasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
Spring Cloud Config monitor;

- Config repository de bir deÄŸiÅŸiklik olduÄŸunda github webhook ile config servise bilgi verir. Config servis de rabbit mq ile mikroservislere mesaj gÃ¶nderir. Mikroservisler de yeniden baÅŸlatÄ±lmasÄ±na gerek kalmadan kendilerini otomatik yenilerler.

- Spring Cloud Config Monitor, Spring Cloud Config Server ile birlikte Ã§alÄ±ÅŸan bir mekanizmadÄ±r ve konfigÃ¼rasyon deÄŸiÅŸikliklerini dinleyerek, ilgili mikroservisleri bu deÄŸiÅŸikliklerden haberdar eder. Bu sayede, bir servis manuel yeniden baÅŸlatÄ±lmadan yeni konfigÃ¼rasyonu alabilir.

NasÄ±l Ã‡alÄ±ÅŸÄ±r? 

1. Spring Cloud Config Server ile merkezi bir yapÄ±landÄ±rma yÃ¶netimi saÄŸlanÄ±r. Genellikle bir Git deposu kullanÄ±lÄ±r.

2. Spring Cloud Bus ile RabbitMQ veya Kafka gibi bir mesajlaÅŸma altyapÄ±sÄ± Ã¼zerinden mikroservislere bildirim gÃ¶nderilir.

3. Spring Cloud Config Monitor, Git deposundaki yapÄ±landÄ±rma deÄŸiÅŸikliklerini algÄ±lar ve bir Webhook (Ã¶rneÄŸin, GitHub veya GitLab Webhookâ€™u) Ã¼zerinden bir HTTP isteÄŸi alÄ±r.

4. Gelen istek Ã¼zerine, ilgili servislere mesaj gÃ¶ndererek konfigÃ¼rasyonlarÄ±nÄ± yenilemelerini saÄŸlar.

- config server projesinde pom.xml dosyasÄ±na depency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-config-monitor</artifactId>
</dependency>

- config server application.yml dosyasÄ±na aÅŸaÄŸÄ±daki konfigÃ¼rasyonub ekliyoruz.

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- config server application.yml dosyasÄ±na rabbit mq konfigÃ¼rasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
- Daha sonra github config dosyalarÄ±mÄ±zÄ±n bulunduÄŸu (card-prod.yml, accounts.yml vb.) repositorymizde ayarlar kÄ±smÄ±nda webhook atif ediyoruz.


Update docker compose to adapt config server changes;

- docker-compose isminde mikroservislerin olduÄŸu dizinde bir kalsÃ¶r aÃ§tÄ±k ve daha Ã¶nce oluÅŸturduÄŸumuz docker-compose.yml dosyasÄ±nÄ± bu kalsÃ¶re taÅŸÄ±dÄ±k. Son olarak configserver projemiz iÃ§in de docker compose dosyasÄ±na konfigÃ¼rasyonlarÄ± ekledik.

- her bir mikroservis iÃ§in docker-compose sayfasÄ±na enviroment deÄŸÅŸkenleri tanÄ±mladÄ±k. 

Docker-compose dosyasÄ±nÄ±n son hali;

services:
  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"

- Bu docker-compose dosyasÄ±na gÃ¶re configserver container Ä±n oluÅŸturulmasÄ± tamamlanmadan accounts containerÄ±nÄ± oluÅŸturmaya baÅŸlayacak. Bu da mikroservislerimizin Ã§alÄ±ÅŸmasÄ±nÄ± engel olur.


LIVENESS and READNESS probes;

- Liveness; projenin ayakta olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.
- Readness; projede trafik akÄ±ÅŸÄ± var mÄ± onu kontrol eder.

- configserver projesindeki application.yml dosyasÄ±na konfigÃ¼rasyonu ekliyoruz.

management:
  
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- actuator endpointleri ile projenin liveness ve readness durumlarÄ±nÄ± kontorl edebiliriz.

- localhost:8071/actuator/health
response;
{"status":"UP","groups":["liveness","readiness"]}

- localhost:8071/actuator/health/liveness
response;
{"status":"UP"}

- eÄŸer porjede sorun var ise status Ã¼ down olur.


Update DOCKER COMPOSE file to adapt congfig server cahnges;

- docker compose dosyasÄ±nda configserver containerÄ±na healthchech konfigÃ¼rasyonlarÄ± ekledik.

- accounts containerÄ±na depends_on ekleyerek, config serverÄ±n saÄŸlÄ±klÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±ÄŸÄ±na emin olunduktan sonra account container Ä± oluÅŸturulmaya baÅŸlanacak.

- spring bus kullandÄ±ÄŸÄ±mÄ±z iÃ§in bizim projelerin Ã§alÄ±ÅŸmasÄ± rabbit  mq projesine de baÄŸlÄ±. bu yÃ¼zden compose dosyasÄ±na rabbit mq servisini de docker compose dosyamÄ±za ekliyoruz.

- docker compose dosyasÄ±nÄ±n son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
      
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"


OPTIMIZE DOCKER COMPOSE FILE;

- docker-compose dosyamÄ±zda tekrar eden konfigÃ¼rasyonlarÄ± common-config.yml adÄ±nda dosya oluÅŸturup oraya taÅŸÄ±dÄ±k.

- docker-compose.yml son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "accounts"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "loans"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "cards"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

networks:
  meryilbank:
    driver: "bridge"

- common-config.yml dosyasÄ±;

services:

  network-deploy-service:
    networks:
      - meryilbank

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m
    environment:
      SPRING_RABBITMQ_HOST: "rabbit"

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
      

Generate docker image and push them to docker hub;

- Ä°lk olarak tÃ¼m projelerin google jib ile image Ä±nÄ± oluÅŸturuyoruz.
(mvn compile jib:dockerBuild) komutunu kullanarak proje dizininde.

- daha sonra oluÅŸturulan imageleri 
docker image push docker.io/merveyilmas/configserver:s6
komutu ile teker teker hub a pushladÄ±k.


DOCKER COMPOSE ile container oluÅŸturma;

- OluÅŸturduÄŸumuz docker-compose/default dizinindeki docker-compose dosyamÄ±zÄ±
docker compose up -d
komutu ile Ã§alÄ±ÅŸtÄ±rÄ±yoruz.

- docker compose down 
ise oluÅŸturulan tÃ¼m containerler Ä± siler.


CREATE MYSQLDB FOR MICROOSERVICES;

- docker run -p 3306:3306 --name accountsdb -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=accountsdb  -d mysql
komutu ile mysql db container Ä± oluÅŸturduk.


UPDATE DOCKER COMPOSE FILE TO CREATE USE MYSQL DB;

- ilk olarak mikroservislerimizin image lerini oluÅŸturuyoruz.
(mvn compile jib:dockerBuild) komutu ile

- Daha sonra docker-compose dosyamÄ±zÄ± gÃ¼ncelliyoruz, db konfigÃ¼rasyonlarÄ± ekliyoruz. Dockor-compose dosyamÄ±zÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in "docker compose up" komutunu dosyamÄ±zÄ±n olduÄŸu dizinde Ã§alÄ±ÅŸtÄ±rÄ±yoruz.


SERVICE DISCOVERY & SERVIICE REGISTRATION in MICROSERVICE:

Spring cloud support for client-side service discovery;

- spring cloud netflix's eureka (for service discovery)
- spring cloud load balancer
- netflix feign client 


EUREKASERVER;

- Eureka Server, Spring Cloud Netflix kÃ¼tÃ¼phanesinin bir parÃ§asÄ± olan ve mikro servis mimarisinde servis keÅŸfi (Service Discovery) saÄŸlayan bir bileÅŸendir.

- Spring initializerdan eurekaserver projesi oluÅŸturuyoruz. Proje oluÅŸtururken 'Eureka Server', 'Config Client' ve 'Spring Boot Actuator' dependency lerini eklememiz gerekir.

- Daha sonra projemizin EurekaserverApplication klasÃ¶rÃ¼nde @EnableEurekaServer anatasyonunu tanÄ±mlÄ±yoruz.

- projemizdeki application.yml dosyasÄ±na ilgili konfigÃ¼rasyon ayarlarÄ±nÄ± ekliyoruz.

- ayrÄ±ca config dosyalarÄ±mÄ±zÄ±n bulunduÄŸu klasÃ¶rÃ¼mÃ¼ze eurekaserver.yml dosyamÄ±zÄ± ekliyoruz. yine ilgili konfigÃ¼rasyonlarÄ±mÄ±zÄ± yazÄ±yoruz.

- daha sonra eurekaserver projemizi Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra 'http://localhost:8070/' adresini ziyaret ettiÄŸimizde eureka server panelimize ulaÅŸÄ±yoruz.


CONNECT EUREKA SERVER from MICROSERVICE;

-  Eureka server a baÄŸlanmak istediÄŸimiz mikroservislerin pom.xml dosyasÄ±na
aÅŸaÄŸÄ±daki dependency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

- ArdÄ±ndan accounts mikroservisi iÃ§erisindeki application.yml dosyasÄ±na aÅŸaÄŸÄ±daki konfigÃ¼rasyonlarÄ± ekliyoruz.

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    shutdown:
      access: unrestricted
  info:
    env:
      enabled: true

eureka:
  instance:
    preferIpAddress: true
  client:
    fetchRegistry: true # KayÄ±tlarÄ± Ã§ekmesini aktif et
    registerWithEureka: true # Kendi kendini kayÄ±t etmesini aktif et
    serviceUrl:
      defaultZone: http://localhost:8070/eureka/

info:
  app:
    name: "accounts"
    description: "Meryil Bank Account Application"
    version: "1.0.0"
    
- Accounts mikroservisine konfigÃ¼rasyonlarÄ± ekledikten sonra projemizi ayaÄŸa kaldÄ±rabiliriz.

- Account mikroservis ayaÄŸa kalktÄ±ktan sonra eureka server a baÄŸlanÄ±p baÄŸlanmadÄ±ÄŸÄ±nÄ± "http://localhost:8070/" adresinden (euureka server proje portu) kontrol edebiliriz. AyrÄ±ca http://localhost:8070/ adresinde mikroservis ismine tÄ±klayarak application dosyasÄ±na tanÄ±mladÄ±ÄŸÄ±mÄ±z mikroservis info bilgilerine ulaÅŸabiliriz. (http://192.168.80.171:8080/actuator/info)

- Bu konfigÃ¼rasyonlarÄ± cards ve loans mikroservislerine de uygulayacaÄŸÄ±z.

- http://localhost:8070/eureka/apps adresinden eureka server a baÄŸlanan tÃ¼m mikroservis bilgilerini gÃ¶rebiliriz.

!NOT: Mikroservislerimizi ayaÄŸa kaldÄ±rmadan Ã¶nce ilk "configserver" Ä± daha sonra "eurekaserver" Ä± ayaÄŸa kaldÄ±rmamÄ±z gerekir. Yoksa mikroservisimiz Ã§alÄ±ÅŸmaz.

- http://localhost:8080/actuator/shutdown
- http://localhost:8090/actuator/shutdown
- http://localhost:9000/actuator/shutdown
yukarÄ±daki gibi mikroservislere istek attÄ±ÄŸÄ±mÄ±zda Ã§alÄ±ÅŸmalarÄ±nÄ± durdurabiliriz.

!NOT: Mikroservisler her 30 saniyede bir eureka server a heartbeat gÃ¶nderirler. Ayakta olduklarÄ±nÄ± sÃ¶ylemek iÃ§in.


FEIGN CLIENT;

- Ä°lk olarak ilgili dependency i mikroservislerimize ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

- Daha sonra application dosyalarÄ±na @EnableFeignClients anatasyonunu ekliyoruz.

- Accounts mikroservisinde service paketi altÄ±na client adÄ±nda bir paket ekliyoruz. Ve istek atacaÄŸÄ±mÄ±z service iÃ§in bir interface oluÅŸturuyoruz.

Ã–r;

@FeignClient("cards")
public interface CardsFeignClient {

    @GetMapping(value = "/api/fetch", consumes = "application/json")
    public ResponseEntity<CardsDto> fetchCardDetails(@RequestParam String mobileNumber);
}

- Burada @FeignClient("cards") eurekaserverda mikroservis ismi ne ise anatasyon iÃ§erisine de o ismi yazÄ±yoruz.

- BÃ¶ylece mikroservislerimiz feign client aracÄ±lÄ±ÄŸÄ± ile eurekaserver a istek atarlar ve eurekaserver da istek atÄ±lan mikroservise yÃ¶nlendirir.


EUREKA SERVER Self-Preservation MODE;

- Eureka Server'Ä±n Self-Preservation Mode (Kendini Koruma Modu), aÄŸ kesintileri veya ani servis kayÄ±plarÄ± gibi durumlarda yanlÄ±ÅŸlÄ±kla saÄŸlÄ±klÄ± servisleri silmemek iÃ§in geliÅŸtirilmiÅŸ bir mekanizmadÄ±r.

Neden Gerekli?
Eureka Client'lar belirli aralÄ±klarla heartbeat (kalp atÄ±ÅŸÄ±) mesajlarÄ± gÃ¶ndererek Eureka Serverâ€™a hala Ã§alÄ±ÅŸtÄ±klarÄ±nÄ± bildirir. Ancak aÄŸ baÄŸlantÄ±sÄ± koparsa veya gecikmeler yaÅŸanÄ±rsa, Eureka Server client'larÄ±n aslÄ±nda Ã§alÄ±ÅŸÄ±yor olup olmadÄ±ÄŸÄ±nÄ± anlayamaz.

EÄŸer Self-Preservation Mode kapalÄ± olursa ve Eureka belirlenen sÃ¼re iÃ§inde heartbeat alamazsa, servisi kayÄ±ttan siler. Ancak bu bazen hatalÄ± olabilir, Ã§Ã¼nkÃ¼ servis Ã§alÄ±ÅŸÄ±yor olabilir fakat sadece geÃ§ici bir aÄŸ sorunu yaÅŸanÄ±yor olabilir.

Bunu Ã¶nlemek iÃ§in Self-Preservation Mode, belirli bir eÅŸik deÄŸerinin altÄ±na dÃ¼ÅŸmedikÃ§e servisleri silmemeyi tercih eder.

DOCKER COMPOSE dosyasÄ±nÄ± gÃ¼ncelleme eureka servis iÃ§in;

- Ä°lk olarak eurekaserver a google jib dependency i ekliyoruz image oluÅŸturabilmek iÃ§in.

- docker-compose.yml dosyasÄ± son hali;

services:

#  accountsdb:
#    container_name: accountsdb
#    ports:
#      - 3307:3306
#    environment:
#      MYSQL_DATABASE: accountsdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config
#
#  cardsdb:
#    container_name: cardsdb
#    ports:
#      - 3308:3306
#    environment:
#      MYSQL_DATABASE: cardsdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config
#
#  loansdb:
#    container_name: loansdb
#    ports:
#      - 3309:3306
#    environment:
#      MYSQL_DATABASE: loansdb
#    extends:
#      file: common-config.yml
#      service: microservice-db-config

  configserver:
    image: "merveyilmas/configserver:s8"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  eurekaserver:
    image: "merveyilmas/eurekaserver:s8"
    container_name: eurekaserver-ms
    ports:
      - "8070:8070"
    depends_on:
      configserver:
        condition: service_healthy
    healthcheck:
      test: "curl --fail --silent localhost:8070/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-configserver-config
    environment:
      SPRING_APPLICATION_NAME: "eurekaserver"

  accounts:
    image: "merveyilmas/accounts:s8"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    environment:
      SPRING_APPLICATION_NAME: "accounts"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://accountsdb:3306/accountsdb"
    depends_on:
#      accountsdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  loans:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms
    ports:
      - "8090:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://loansdb:3306/loansdb"
    depends_on:
#      loansdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  cards:
    image: "merveyilmas/cards:s8"
    container_name: cards-ms
    ports:
      - "9000:9000"
    environment:
      SPRING_APPLICATION_NAME: "cards"
#      SPRING_DATASOURCE_URL: "jdbc:mysql://cardsdb:3306/cardsdb"
    depends_on:
#      cardsdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-configserver-config

networks:
  meryilbank:
    driver: "bridge"


- common-config.yml dosyasÄ± son hali;

services:

  network-deploy-service:
    networks:
      - meryilbank

#  microservice-db-config:
#    extends:
#      service: network-deploy-service
#    image: mysql
#    healthcheck:
#      test: [ "CMD", "mysqladmin" ,"ping", "-h", "localhost" ]
#      timeout: 10s
#      retries: 10
#      interval: 10s
#      start_period: 10s
#    environment:
#      MYSQL_ROOT_PASSWORD: root

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
      #SPRING_DATASOURCE_USERNAME: root
      #SPRING_DATASOURCE_PASSWORD: root

  microservice-eureka-config:
    extends:
      service: microservice-configserver-config
    environment:
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eurekaserver:8070/eureka/
      
Load balancing;

  loans:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms
    ports:
      - "8090:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_DATASOURCE_URL: "jdbc:mysql://host.docker.internal:3306/UdemyLoans"
    depends_on:
#      loansdb:
#        condition: service_healthy
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-eureka-config

  loans1:
    image: "merveyilmas/loans:s8"
    container_name: loans-ms1
    ports:
      - "8091:8090"
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_DATASOURCE_URL: "jdbc:mysql://host.docker.internal:3306/UdemyLoans"
    depends_on:
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    extends:
      file: common-config.yml
      service: microservice-eureka-config

- Docker compose dosyamÄ±zda yukarÄ±daki gibi iki tane loans container Ä± tanÄ±mlarsak eurekaserver arka planda loans mikroservisine gelen istekleri yoÄŸunluÄŸa gÃ¶re iki mikroservise daÄŸÄ±tÄ±r.


API Gateway;

- Spring Cloud Gateway, Spring ekosisteminde API Gateway olarak kullanÄ±lan hafif ve Ã¶lÃ§eklenebilir bir Ã§Ã¶zÃ¼mdÃ¼r. API Gateway, mikro hizmet mimarisinde istemciler (frontend, mobil uygulamalar vb.) ile arka plandaki servisler arasÄ±nda bir giriÅŸ noktasÄ± olarak Ã§alÄ±ÅŸÄ±r.

ğŸš€ Spring Cloud Gatewayâ€™in Temel Ã–zellikleri:
âœ… Reverse Proxy: Gelen HTTP isteklerini uygun mikro servislere yÃ¶nlendirir.
âœ… Route (YÃ¶nlendirme): Belirli kurallara (URL pattern, header, vs.) gÃ¶re istekleri belirli servislere iletir.
âœ… Filter (Filtreleme): Gelen ve giden istekler Ã¼zerinde deÄŸiÅŸiklik yapabilir (Ã¶rneÄŸin, JWT doÄŸrulama, CORS iÅŸlemleri, loglama).
âœ… Load Balancing: Gelen trafiÄŸi farklÄ± servis kopyalarÄ±na yÃ¶nlendirebilir.
âœ… Circuit Breaker: Servislerin Ã§Ã¶kmesini Ã¶nlemek iÃ§in koruyucu mekanizmalar sunar (Resilience4J gibi).
âœ… Rate Limiting: Belirli bir sÃ¼re iÃ§inde belirli sayÄ±da isteÄŸe izin vererek DDOS saldÄ±rÄ±larÄ±na karÅŸÄ± koruma saÄŸlar.

- Gateway iÃ§in spring boot projemizi oluÅŸturuyoruz ve aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekliyoruz.


  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <scope>runtime</scope>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

- pom.xml dosaysÄ±na google jib baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± ekliyoruz, image oluÅŸturabilmek iÃ§in

<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
		</plugin>
		<plugin>
			<groupId>com.google.cloud.tools</groupId>
			<artifactId>jib-maven-plugin</artifactId>
			<version>3.4.4</version>
			<configuration>
				<to>
					<image>merveyilmas/${project.artifactId}:s9</image>
				</to>
			</configuration>
		</plugin>
	</plugins>
</build>

- config repository sine gatewayserver.yml dosyasÄ±nÄ± ekliyoruz ve aÅŸaÄŸÄ±daki konfigÃ¼rasyonlarÄ± tanÄ±mlÄ±yoruz.

server:
  port: 8072

eureka:
  instance:
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: "http://localhost:8070/eureka/"


- gatewayserver projesindeki application.yml dosyasÄ±na da aÅŸaÄŸÄ±daki konfigÃ¼rasyonlarÄ± ekliyoruz.

spring:
  application:
    name: "gatewayserver"
  config:
    import: "optional:configserver:http://localhost:8071/"
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      access: unrestricted
  info:
    env:
      enabled: true

info:
  app:
    name: "gatewayserver"
    description: "Meryil Bank Gatewayserver Application"
    version: "1.0.0"
    
- mikroservisleri Ã§alÄ±ÅŸtÄ±rma sÄ±rasÄ±;
configserver -> eurekaserver -> accounts, loans, cards -> gatewayserver

- http://localhost:8072/actuator
ile gateway server Ä±n actuator endpointlerini listeleriz.

- http://localhost:8072/actuator/gateway/routes
endpoint'i Spring Cloud Gateway tarafÄ±ndan yÃ¶netilen tÃ¼m aktif rotalarÄ± (routes) JSON formatÄ±nda dÃ¶ndÃ¼rÃ¼r. (accounts, loans, cards)

- http://localhost:8072/ACCOUNTS/api/create
gateway routesdan Ã¶ÄŸrendiÄŸimiz yol ile accounts mikroservisine yukarÄ±daki gibi istek atarÄ±z.

- accounts mikroservisine yukarÄ±daki gibi istek atarken mikroservis ismini ACCOUNTS gibi bÃ¼yÃ¼k yazmamÄ±z gerekir bu ÅŸekilde tanÄ±mlÄ± olduÄŸu iÃ§in. Mikroservis ismini kÃ¼Ã§Ã¼k harflerle yazabilmek iÃ§in gateway servisine 

spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
          lowerCaseServiceId: true

konfigÃ¼rasyonunu ekledik. Yani ÅŸimdi "http://localhost:8072/accounts/api/fetch?mobileNumber=1234567670" ÅŸeklinde istek atabiliriz.

- Mikroservis endpointlerimizi konfigÃ¼re etmek iÃ§in "GatewayserverApplication" dosyamÄ±za aÅŸaÄŸÄ±daki fonksiyonu ekledik.

@Bean
public RouteLocator meryilBankRouteConfig(RouteLocatorBuilder routeLocatorBuilder) {
	return routeLocatorBuilder.routes()
			.route(p -> p
					.path("/meryilbank/accounts/**")
					.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://ACCOUNTS")) // eureka serverdaki mikroservis adÄ± ne ise o olacak
			.route(p -> p
					.path("/meryilbank/loans/**")
					.filters( f -> f.rewritePath("/meryilbank/loans/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://LOANS"))
			.route(p -> p
					.path("/meryilbank/cards/**")
					.filters( f -> f.rewritePath("/meryilbank/cards/(?<segment>.*)","/${segment}")
							.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
					.uri("lb://CARDS")).build();
}

ÅŸimdi ise hem "http://localhost:8072/accounts/api/fetch?mobileNumber=1234567670" hem de "http://localhost:8072/meryilbank/accounts/api/fetch?mobileNumber=1234567670" endpointleri ile istek atabiliriz.

Tracing/Logging using GATEWAY;

- Spring Cloud API Gateway'deki filters (filtreler), gelen ve giden HTTP isteklerini deÄŸiÅŸtirmek veya yÃ¶nlendirmek iÃ§in kullanÄ±lÄ±r. Filtreler, istekleri ve yanÄ±tlarÄ± inceleyerek gÃ¼venlik, doÄŸrulama, yÃ¶nlendirme, dÃ¶nÃ¼ÅŸÃ¼m ve diÄŸer iÅŸlevleri yerine getirebilir.

Ne Ä°ÅŸe Yarar?
*GÃ¼venlik: Kimlik doÄŸrulama ve yetkilendirme iÅŸlemleri yapabilir.
*Loglama & Ä°zleme: Gelen ve giden istekleri izleyip loglayabilir.
*DÃ¶nÃ¼ÅŸtÃ¼rme: Ä°stek veya yanÄ±t verilerini deÄŸiÅŸtirebilir (Ã¶rn. JSON'dan XML'e Ã§evirme).
*Rate Limiting: Belirli bir sÃ¼re iÃ§inde belirli bir sayÄ±da isteÄŸe izin verebilir.
*YÃ¶nlendirme & ManipÃ¼lasyon: URI deÄŸiÅŸtirme, baÅŸlÄ±k ekleme gibi iÅŸlemleri gerÃ§ekleÅŸtirebilir.


- gatewayserver projemize "filters" adÄ±nda bir paket ekliyoruz be bu pakete de FilterUtility, RequestTraceFilter ve ResponseTraceFilter sÄ±nÄ±flarÄ±nÄ± iÃ§erisindeki konfigÃ¼rasyonlar ile beraber ekliyoruz.

FilterUtility;

- Bu sÄ±nÄ±f, HTTP isteklerinin baÅŸlÄ±klarÄ±yla (headers) ilgili bazÄ± yardÄ±mcÄ± iÅŸlevler saÄŸlar ve correlation id (iliÅŸkilendirme kimliÄŸi) gibi baÅŸlÄ±klarÄ± yÃ¶netir. FilterUtility sÄ±nÄ±fÄ±, Ã¶zellikle API Gateway veya servisler arasÄ± iletiÅŸimde kullanÄ±lan Correlation ID'yi alÄ±p set etme iÅŸlemlerini yapar. Correlation ID, genellikle daÄŸÄ±tÄ±k sistemlerde her isteÄŸi izlemek ve hata ayÄ±klamak iÃ§in kullanÄ±lÄ±r.

Ã–zetle Ne Yapar?
Correlation ID Okuma: Gelen isteklerdeki eazybank-correlation-id baÅŸlÄ±ÄŸÄ±nÄ± alÄ±r.
Yeni BaÅŸlÄ±k Ekleme: Ä°stek Ã¼zerine verilen baÅŸlÄ±k adÄ±nÄ± ve deÄŸerini ekler.
Correlation ID Ekleme: Gelen isteÄŸe ya da yeni oluÅŸturulan isteÄŸe correlation-id baÅŸlÄ±ÄŸÄ± ekler.
Bu sÄ±nÄ±f, Ã¶zellikle mikroservisler arasÄ±ndaki isteklerin izlenebilirliÄŸini artÄ±rmak iÃ§in faydalÄ±dÄ±r. Correlation ID, bir isteÄŸin tÃ¼m yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ takip etmek iÃ§in kullanÄ±lÄ±r ve bu sÄ±nÄ±f, bu baÅŸlÄ±kla ilgili iÅŸlemleri yÃ¶netmek iÃ§in basit bir yardÄ±mcÄ± iÅŸlev saÄŸlar.

RequestTraceFilter;

- Bu sÄ±nÄ±f, Spring Cloud Gateway'de global bir filtre olarak Ã§alÄ±ÅŸÄ±r ve her gelen HTTP isteÄŸinde correlation-id baÅŸlÄ±ÄŸÄ±nÄ± yÃ¶netir. AmaÃ§, gelen isteklerde correlation-id olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek, yoksa yeni bir tane oluÅŸturmak ve istek baÅŸlÄ±klarÄ±na eklemektir. AyrÄ±ca, loglama yaparak, her iki durumu da (baÅŸlÄ±k var mÄ±, yoksa oluÅŸturuldu) izler.

Ã–zetle Ne Yapar?
Correlation ID KontrolÃ¼:

Her gelen istek iÃ§in, correlation-id baÅŸlÄ±ÄŸÄ±nÄ±n mevcut olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.
EÄŸer baÅŸlÄ±k varsa, var olan correlation-id'yi loglar.
EÄŸer baÅŸlÄ±k yoksa, yeni bir correlation-id oluÅŸturur, baÅŸlÄ±klara ekler ve bunu loglar.
Loglama:

logger.debug() kullanarak, iÅŸlem sÄ±rasÄ±nda correlation-id'nin mevcut olup olmadÄ±ÄŸÄ±nÄ± ve hangi correlation-id'nin kullanÄ±ldÄ±ÄŸÄ±nÄ± debug seviyesinde loglar.
Correlation ID Ekleme:

EÄŸer correlation-id yoksa, yeni bir UUID oluÅŸturup istek Ã¼zerine ekler. Bu sayede daÄŸÄ±tÄ±k sistemlerdeki tÃ¼m iÅŸlemler izlenebilir hale gelir.
KullanÄ±m Senaryosu
Mikroservis Mimarisi: Bir API Gateway Ã¼zerinden gelen isteklerin takip edilmesini saÄŸlar. EÄŸer bir isteÄŸin correlation-id'si yoksa, bu sÄ±nÄ±f bir tane oluÅŸturur ve bÃ¶ylece tÃ¼m sistemdeki mikroservisler arasÄ±nda bu isteÄŸin izlenebilirliÄŸini artÄ±rÄ±r. Bu, hata ayÄ±klama, izleme ve performans takibi iÃ§in kritik olabilir.

ResponseTraceFilter;

- Bu sÄ±nÄ±f, Spring Cloud Gateway'de gelen ve giden istekler iÃ§in correlation-id baÅŸlÄ±ÄŸÄ±nÄ± iÅŸleyen bir GlobalFilter oluÅŸturur. Ã–zellikle, giden yanÄ±tlara correlation-id baÅŸlÄ±ÄŸÄ±nÄ± ekler. ResponseTraceFilter sÄ±nÄ±fÄ±, isteklerin ardÄ±ndan yapÄ±lan iÅŸlemler iÃ§in giden yanÄ±t baÅŸlÄ±klarÄ±na correlation-id ekleyerek, yanÄ±tlarÄ± da izlenebilir kÄ±lar.

Ã–zet
Bu sÄ±nÄ±f, her gelen isteÄŸin yanÄ±tÄ±na correlation-id baÅŸlÄ±ÄŸÄ±nÄ± ekleyerek, tÃ¼m sistemdeki iÅŸlemlerin izlenmesini saÄŸlar. Yani, isteklerdeki correlation-id, yanÄ±tlara da aktarÄ±lÄ±r ve sistemdeki bÃ¼tÃ¼n iÅŸlem adÄ±mlarÄ± arasÄ±ndaki iliÅŸkiyi izlemeye yardÄ±mcÄ± olur.

- gatewayserver projemizde application.yml dosyasÄ±na detaylÄ± loglarÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in aÅŸaÄŸÄ±daki konfigÃ¼rasyonu ekliyoruz.

logging:
  level:
    com:
      meryilbank:
        gatewayserver: DEBUG
        

- Daha sonra log konfigÃ¼rasyonlarÄ±nÄ± diÄŸer mikroservislere de (accounts, loans ve cards) a ekliyoruz.

- EklediÄŸimiz konfigÃ¼rasyon sonucu gatewayserver run terminalde aÅŸaÄŸÄ±daki correlation-id
loglarÄ±nÄ± gÃ¶rÃ¼yoruz.

2025-03-18T15:43:51.932+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.RequestTraceFilter         : meryilbank-correlation-id generated in RequestTraceFilter : 2b80f73b-225d-4f39-9cad-1661e4f16bb7
2025-03-18T15:43:51.938+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.ResponseTraceFilter        : Updated the correlation id to the outbound headers: 2b80f73b-225d-4f39-9cad-1661e4f16bb7
2025-03-18T15:45:00.131+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.RequestTraceFilter         : meryilbank-correlation-id generated in RequestTraceFilter : efdb2c96-e333-4b87-97df-fa6bad4b781c
2025-03-18T15:45:00.349+03:00 DEBUG 32723 --- [gatewayserver] [or-http-epoll-5] c.m.g.filters.ResponseTraceFilter        : Updated the correlation id to the outbound headers: efdb2c96-e333-4b87-97df-fa6bad4b781c
        
Correlation ID;

- Correlation ID (iliÅŸkilendirme kimliÄŸi), daÄŸÄ±tÄ±k sistemlerde bir isteÄŸi, onunla iliÅŸkili tÃ¼m iÅŸlemlerle takip etmek ve izlemek iÃ§in kullanÄ±lan benzersiz bir tanÄ±mlayÄ±cÄ±dÄ±r. Ã–zellikle mikroservis mimarilerinde, bir kullanÄ±cÄ±nÄ±n veya bir sistemin baÅŸlattÄ±ÄŸÄ± iÅŸlem sÄ±rasÄ±ndaki tÃ¼m adÄ±mlarÄ±n (istekler, yanÄ±tlar, hata mesajlarÄ± vb.) izlenebilmesi iÃ§in kullanÄ±lÄ±r. Bu sayede bir iÅŸlem sÃ¼reci boyunca farklÄ± servisler arasÄ±nda yapÄ±lan Ã§aÄŸrÄ±lar birbirine baÄŸlanabilir.

- accounts, loans ve cards mikroservislerinin bazÄ± controller fonksiyonlarÄ±na correlationId deÄŸiÅŸkenini ekliyoruz.

Ã–r;
@GetMapping("fetchCustomerDetails")
public ResponseEntity<CustomerDetailsDto> fetchCustomerDetails(@RequestHeader("meryilbank-correlation-id") String correlationId,
                                                           @RequestParam
                                                           @Pattern(regexp = "(^$|[0-9]{10})", message = "Mobile number must be 10 digits")
                                                           String mobileNumber) {
logger.debug("meryilBank-correlation-id found: {} ", correlationId);
CustomerDetailsDto customerDetailsDto = iCustomersService.fetchCustomerDetails(mobileNumber, correlationId);
return ResponseEntity.status(HttpStatus.SC_OK).body(customerDetailsDto);
}
    
Design Patterns Around API Gateway;

API Gateway Pattern;

- API Gateway Pattern, mikro hizmet mimarisinde sÄ±kÃ§a kullanÄ±lan bir tasarÄ±m desenidir. API Gateway, istemciler (mobil uygulamalar, web istemcileri vb.) ile mikro hizmetler arasÄ±nda bir aracÄ± katman olarak gÃ¶rev yapar. Temel amacÄ±, istemcilerin doÄŸrudan mikro hizmetlere eriÅŸmesini engelleyerek gÃ¼venliÄŸi, yÃ¶netilebilirliÄŸi ve performansÄ± artÄ±rmaktÄ±r.

API Gatewayâ€™in Ã‡alÄ±ÅŸma MekanizmasÄ±
Ä°stemci, API Gatewayâ€™e HTTP isteÄŸi gÃ¶nderir.
API Gateway, isteÄŸi inceler, kimlik doÄŸrulama gibi iÅŸlemleri gerÃ§ekleÅŸtirir.
API Gateway, uygun mikro hizmete isteÄŸi yÃ¶nlendirir ve yanÄ±tÄ± alÄ±r.
YanÄ±t, API Gateway tarafÄ±ndan formatlanarak istemciye iletilir.

Gateway Routing Pattern;

- Gateway Routing Pattern, API Gatewayâ€™in gelen HTTP isteklerini uygun mikro hizmetlere yÃ¶nlendirmesini (routing) saÄŸlayan bir tasarÄ±m desenidir. Bu desen, API Gatewayâ€™in sadece bir proxy olarak Ã§alÄ±ÅŸmasÄ±nÄ± deÄŸil, aynÄ± zamanda gelen istekleri inceleyerek dinamik veya statik kurallara gÃ¶re yÃ¶nlendirme yapmasÄ±nÄ± iÃ§erir.

ğŸ“Œ Gateway Routing Patternâ€™in AvantajlarÄ±
âœ… Mikro hizmetlerin gizlenmesi â†’ DÄ±ÅŸ dÃ¼nyaya doÄŸrudan aÃ§Ä±lmazlar.
âœ… Ä°stek yÃ¶nlendirme ve dÃ¶nÃ¼ÅŸtÃ¼rme â†’ API Gateway, ihtiyaca gÃ¶re path veya parametreleri deÄŸiÅŸtirebilir.
âœ… GÃ¼venlik ve doÄŸrulama â†’ JWT, OAuth gibi kimlik doÄŸrulama mekanizmalarÄ±yla entegre edilebilir.
âœ… YÃ¼k dengeleme (Load Balancing) â†’ Gelen trafiÄŸi Ã¶lÃ§eklenebilir ÅŸekilde farklÄ± instancelara daÄŸÄ±tabilir.
âœ… Ã–nbellekleme ve hÄ±zlandÄ±rma â†’ SÄ±k yapÄ±lan istekleri Gateway Ã¼zerinde cacheâ€™leyebilir.

Gateway Offloading Pattern;

- Gateway Offloading Pattern, API Gatewayâ€™in kimlik doÄŸrulama, gÃ¼venlik, hÄ±z sÄ±nÄ±rlama (rate limiting), Ã¶nbellekleme (caching) ve yÃ¼k dengeleme (load balancing) gibi iÅŸlemleri Ã¼stlenmesini saÄŸlayan bir tasarÄ±m desenidir. Bu sayede mikro hizmetler sadece iÅŸ mantÄ±ÄŸÄ±na odaklanÄ±r ve ekstra yÃ¼kten kurtulmuÅŸ olur.

ğŸ“Œ API Gateway Offloading KullanÄ±m SenaryolarÄ±
âœ… Kimlik doÄŸrulama (OAuth, JWT) mikro hizmetlerden alÄ±nÄ±r, Gatewayâ€™e yÃ¼klenir.
âœ… Rate limiting (HÄ±z sÄ±nÄ±rlama) sayesinde DDoS saldÄ±rÄ±larÄ± Gateway seviyesinde engellenir.
âœ… Mikro hizmetler sadece iÅŸ mantÄ±ÄŸÄ±na odaklanÄ±r, gÃ¼venlik ve yÃ¼k yÃ¶netimi API Gatewayâ€™e devredilir.
âœ… Ã–nbellekleme ile gereksiz istekler engellenir, performans artar.

Backend for Frontend (BFF) Pattern;

- Backend for Frontend (BFF) Pattern, farklÄ± istemci tÃ¼rleri (web, mobil, IoT vb.) iÃ§in Ã¶zelleÅŸtirilmiÅŸ API'ler sunan bir backend katmanÄ± oluÅŸturmayÄ± amaÃ§layan bir mimari desendir.

Klasik API Gateway yaklaÅŸÄ±mÄ±nÄ±n aksine, her istemci (mobil/web) iÃ§in ayrÄ± bir backend servis Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

ğŸ“Œ Neden BFF KullanÄ±lÄ±r?
FarklÄ± istemcilerin ihtiyaÃ§larÄ± farklÄ±dÄ±r:

Mobil uygulamalar daha az veri Ã§eker, dÃ¼ÅŸÃ¼k gecikme ister.
Web istemcileri daha geniÅŸ veri setlerine eriÅŸebilir.
IoT cihazlarÄ± genellikle hafif ve dÃ¼ÅŸÃ¼k gÃ¼Ã§ tÃ¼ketimli istekler yapar.
BFF, her istemciye Ã¶zel bir API sunarak gereksiz veri ve iÅŸ yÃ¼kÃ¼nÃ¼ azaltÄ±r.

ğŸ“Œ SonuÃ§
ğŸ”¹ Backend for Frontend Pattern, her istemciye Ã¶zel API sunarak performans, Ã¶lÃ§eklenebilirlik ve Ã¶zelleÅŸtirme aÃ§Ä±sÄ±ndan bÃ¼yÃ¼k avantajlar saÄŸlar.
ğŸ”¹ API Gateway yerine deÄŸil, onunla birlikte kullanÄ±labilir!
ğŸ”¹ Ã–zellikle bÃ¼yÃ¼k Ã¶lÃ§ekli projelerde, mobil ve web istemcileri arasÄ±nda bÃ¼yÃ¼k farklÄ±lÄ±klar varsa Ã¶nerilir.

Gateway Aggregator Pattern;

- Gateway Aggregator Pattern (diÄŸer adÄ±yla Composition Pattern), API Gatewayâ€™in birden fazla mikro hizmetten gelen verileri toplayarak tek bir istemci yanÄ±tÄ± oluÅŸturmasÄ±nÄ± saÄŸlayan bir tasarÄ±m desenidir.

Klasik mikro hizmet yaklaÅŸÄ±mÄ±nda, istemciler (mobil/web) farklÄ± mikro hizmetlerden ayrÄ± ayrÄ± veri Ã§ekmek zorundadÄ±r. Bu durum:

AÄŸ trafiÄŸini artÄ±rÄ±r.
Ä°stemcinin fazladan iÅŸ yÃ¼kÃ¼ taÅŸÄ±masÄ±na neden olur.
Gecikmeleri artÄ±rabilir.
Gateway Aggregator Pattern, bu istekleri API Gateway Ã¼zerinden birleÅŸtirerek istemciye tek bir API Ã§aÄŸrÄ±sÄ± ile optimize edilmiÅŸ bir yanÄ±t sunar.

ğŸ“Œ Neden Gateway Aggregator KullanÄ±lÄ±r?
âœ… Mikro hizmetler istemciden gizlenir.
âœ… Ä°stemci daha az API Ã§aÄŸrÄ±sÄ± yapar.
âœ… AÄŸ trafiÄŸi azalÄ±r, performans artar.
âœ… Veri birleÅŸtirme (composition) API Gateway tarafÄ±ndan yapÄ±lÄ±r.
âœ… Mobil cihazlar iÃ§in optimize edilmiÅŸ daha kÃ¼Ã§Ã¼k yanÄ±tlar saÄŸlanabilir.

ğŸ“Œ Gateway Aggregator Ã‡alÄ±ÅŸma MantÄ±ÄŸÄ±
1ï¸âƒ£ Ä°stemci, API Gateway'e tek bir istek yapar.
2ï¸âƒ£ API Gateway, farklÄ± mikro hizmetlerden veri Ã§eker.
3ï¸âƒ£ Verileri birleÅŸtirerek (compose) istemciye tek bir yanÄ±t olarak dÃ¶ner.


Add Gatewayserver to Docker Compose File;

- Ä°lk olarak accounts, loans ve cards a ayakta olduklarÄ±nÄ± anlamak iÃ§in docker comppose da aÅŸaÄŸÄ±daki konfigÃ¼rasyonu ekledik.

healthcheck:
	test: "curl --fail --silent localhost:9000/actuator/health/readiness | grep UP || exit 1"
	interval: 10s
	timeout: 5s
	retries: 10
	start_period: 10s

- Ve gatewayserver iÃ§in de docker compose dosyasÄ±na aÅŸaÄŸÄ±daki yapÄ±landÄ±rmayÄ± ekledik.

  gatewayserver:
    image: "merveyilmas/gatewayserver:s9"
    container_name: gatewayserver-ms
    ports:
      - "8072:8072"
    depends_on:
      accounts:
        condition: service_healthy
      loans:
        condition: service_healthy
      cards:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "gatewayserver"
    extends:
      file: common-config.yml
      service: microservice-eureka-config


MAKING MICROSERVICE RESIELLIENT(DayanÄ±klÄ±);

Resilience4j;
- Resilience4j, Java iÃ§in geliÅŸtirilmiÅŸ, mikroservis mimarilerinde yaygÄ±n olarak kullanÄ±lan hata toleransÄ± (fault tolerance) saÄŸlayan hafif (lightweight) bir kÃ¼tÃ¼phanedir.

ğŸ“Œ Temel AmacÄ± Nedir?
DaÄŸÄ±tÄ±k sistemlerde oluÅŸabilecek gecikmeleri, baÅŸarÄ±sÄ±zlÄ±klarÄ± veya yoÄŸun yÃ¼kleri yÃ¶netilebilir hale getirmek.

ğŸ”§ Resilience4j'nin SaÄŸladÄ±ÄŸÄ± Temel ModÃ¼ller
ModÃ¼l	AÃ§Ä±klama
Circuit Breaker: HatalÄ± Ã§alÄ±ÅŸan sistem Ã§aÄŸrÄ±larÄ±nÄ± keserek sistemi korur.
Rate Limiter: Belirli bir zaman aralÄ±ÄŸÄ±nda yapÄ±labilecek Ã§aÄŸrÄ± sayÄ±sÄ±nÄ± sÄ±nÄ±rlar.
Retry:	Hata alan iÅŸlemleri otomatik olarak yeniden denemeyi saÄŸlar.
Bulkhead: Kaynak izolasyonu saÄŸlar. Bir servisteki yoÄŸunluk diÄŸerini etkilemez.
TimeLimiter: Maksimum Ã§alÄ±ÅŸtÄ±rma sÃ¼resi belirler, sÃ¼resi dolan Ã§aÄŸrÄ±lar iptal edilir.
Cache: YanÄ±tlarÄ± Ã¶nbelleÄŸe alarak tekrar hesaplamayÄ± engeller.

ğŸ§  Ã–rnek Senaryo: Circuit Breaker
-Bir mikroservis baÅŸka bir servise Ã§aÄŸrÄ± yapÄ±yor ve karÅŸÄ± servis sÄ±k sÄ±k hata veriyorsa:

*Ä°lk baÅŸta Resilience4j bu hatalarÄ± kaydeder.
*Belirli bir eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda, circuit "open" hale gelir ve Ã§aÄŸrÄ±lar hemen kesilir.
*Bir sÃ¼re sonra sistem tekrar "half-open" moda geÃ§er, test Ã§aÄŸrÄ±larÄ± yapÄ±lÄ±r.
*EÄŸer servis iyileÅŸtiyse tekrar "closed" moda dÃ¶ner.


Implementing Circuit Breaker pattern in Gateway;

- gatewayserver projesinde pom.xml dosyasÄ±na aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
</dependency>

- GatewayserverApplication sÄ±nÄ±fÄ±nda "accounts" router Ä±na ".circuitBreaker(config -> config.setName("accountsCircuitBreaker")))" config i ekliyoruz.

.route(p -> p
	.path("/meryilbank/accounts/**")
	.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.circuitBreaker(config -> config.setName("accountsCircuitBreaker")))
	.uri("lb://ACCOUNTS")) // eureka serverdaki mikroservis adÄ± ne ise o olacak

- Daha sonra gatewayserver application.yml dosyasÄ±na circuitbreaker configÃ¼rasyonunu ekliyoruz.

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

- Postman den circuit breakers durumunu kontrol edebilirsin:

http://localhost:8072/actuator/circuitbreakers
http://localhost:8072/actuator/circuitbreakerevents?name=accountsCircuitBreaker

Send callback to customer;
- Hata oluÅŸtuÄŸunda kullanÄ±cÄ±ya hata ile ilgili geri dÃ¶nÃ¼ÅŸ yapmak iÃ§in gatewayserver a "FallbackController" sÄ±nÄ±fÄ± ekliyoruz. Burada support team e hata maili vb. gÃ¶nderebiliriz istersek.

@RestController
public class FallbackController {

    @RequestMapping("/contactSupport")
    public Mono<String> contactSupport() {
        // you can send the email which inside an error to support team
        return Mono.just("An error occurred. Please try after some time or contact support team!!!");
    }
}

- GatewayserverApplication da accounts router Ä±na ".setFallbackUri("forward:/contactSupport")" fallback uri ekliyoruz.

.route(p -> p
	.path("/meryilbank/accounts/**")
	.filters( f -> f.rewritePath("/meryilbank/accounts/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.circuitBreaker(config -> config.setName("accountsCircuitBreaker")
					.setFallbackUri("forward:/contactSupport")))


Implementing Circuit Breaker pattern with FeignClient;

- Accounts mikroservisinde aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekliyoruz:

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>

- Daha sonra "application.yml" dosyasÄ±na aÅŸaÄŸÄ±daki konfigÃ¼rasyonu ekliyoruz:

spring:
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true

- circuirbreaker konfigÃ¼rasyonunu da ekliyoruz:

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

Circuitbreaker for Feign Clients;

- Account mikroservisinde service.client paketi altÄ±na "CardsFallback" ve "LoansFallback"  sÄ±nÄ±flarÄ±nÄ± ekliyoruz:

@Component
public class CardsFallback implements CardsFeignClient{

    @Override
    public ResponseEntity<CardsDto> fetchCardDetails(String correlationId, String mobileNumber) {
        //buraya card mikroservisi hata almasÄ± durumunda yapmak istediklerini yazabilirsin
        return null;
    }
}

@Component
public class LoansFallback implements LoansFeignClient {

    @Override
    public ResponseEntity<LoansDto> fetchLoanDetails(String correlationId, String mobileNumber) {
        return null;
    }
}

- "CardsFeignClient" ve "LoansFeignClient" interfacelerine ise @FeignClient anatasyonuna fallback parametresi ekle.

@FeignClient(name="cards",fallback = CardsFallback.class)
@FeignClient(name="loans",fallback = LoansFallback.class)

- "CustomerServiceImpl" sÄ±nÄ±fÄ±nda "CardsFeignClient" ve "LoansFeignClient" sÄ±nÄ±flarÄ±nÄ± Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z yerde null check kontrolÃ¼ ekliyoruz.


HTTP TIMEOUT CONFIGURATIONS;

- TÃ¼m mikroservisler iÃ§in gateway servisinin application.yml dosyasÄ±na timeout konfigÃ¼rasyonlarÄ±nÄ± ekliyoruz. Eklemezsek 30 sn servisin cevap vermesini bekleriz. EÄŸer "GatewayserverApplication" sÄ±nÄ±fÄ±nda Ã¶zel circuitBreaker konfigÃ¼rasyonu eklemezsek router kÄ±smÄ±nda bu genel timeout sÃ¼releri geÃ§erli olur.

spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
        

ğŸ”§ Retry Pattern Nedir?
Bir iÅŸlem (Ã¶rneÄŸin bir HTTP isteÄŸi, veritabanÄ± Ã§aÄŸrÄ±sÄ±, uzak servis iletiÅŸimi) baÅŸarÄ±sÄ±z olduÄŸunda, hemen hata dÃ¶ndÃ¼rmek yerine belirli bir sÃ¼re ve sayÄ± kadar tekrar denenmesidir.

ğŸ“Œ Ne zaman kullanÄ±lÄ±r?
GeÃ§ici aÄŸ sorunlarÄ±

-AnlÄ±k yoÄŸunluk nedeniyle baÅŸarÄ±sÄ±z olan istekler
-DÄ±ÅŸ sistemin kÄ±sa sÃ¼reli eriÅŸilemez durumda olmasÄ±
-Timeoutâ€™lar veya HTTP 5xx hatalarÄ± gibi durumlar

Implementing Retry pattern in Gateway;

- Gateway mikroservisinde GatewayserverApplication sÄ±nÄ±fÄ±nda loans mikroservis router Ä±na retry konfigÃ¼rasyonlarÄ±nÄ± ekliyoruz.

.route(p -> p
	.path("/meryilbank/loans/**")
	.filters( f -> f.rewritePath("/meryilbank/loans/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.retry(retryConfig -> retryConfig.setRetries(3)
					.setMethods(HttpMethod.GET)
					.setBackoff(Duration.ofMillis(100),Duration.ofMillis(1000),2,true)))
	.uri("lb://LOANS"))


Implementing Retry pattern in accounts microservice;

- AccountsController a konfgÃ¼rasyon eklemek istediÄŸimiz apiye @Retry anatasyonunu ve ilgili fallback metodunu ekliyoruz.

 @Retry(name = "getBuildInfo",fallbackMethod = "getBuildInfoFallback")
    @GetMapping("/build-info")
    public ResponseEntity<String> getBuildInfo() {
        return ResponseEntity.status(HttpStatus.OK).body(buildVersion);
    }

    public ResponseEntity<String> getBuildInfoFallback(Throwable throwable) {
        logger.debug("getBuildInfoFallback() method Invoked");
        return ResponseEntity
                .status(HttpStatus.OK)
                .body("0.9");
    }
    
- Gateway mikroservisine yukarÄ±da tanÄ±mladÄ±ÄŸÄ±mÄ±z retry fallback i iÃ§in aÅŸaÄŸÄ±daki konfigÃ¼rasyon fonksiyonunu "GatewayserverApplication" sÄ±nÄ±fÄ±na tanÄ±mlÄ±yoruz. Ä°lgili apiye istek atÄ±p denemeler sonucu hala hata alÄ±rsak getBuildInfoFallback fonksiyonunda tanÄ±mladÄ±ÄŸÄ±mÄ±z "0.9" yanÄ±tÄ±nÄ± cevap olarak alÄ±rÄ±z.

@Bean
public Customizer<ReactiveResilience4JCircuitBreakerFactory> defaultCustomizer() {
	return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
			.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
			.timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(4)).build()).build());
	}
	

- Postmandan istek attÄ±ÄŸÄ±mÄ±zda retry pattern i uyguladÄ±ÄŸÄ±mÄ±z iÃ§in response header kÄ±smÄ±nda istek atÄ±lan kadar correlation id bulunuyordu. Bunu Ã¶nlemek iÃ§in gateway server da "ResponseTraceFilter" sÄ±nÄ±fÄ±nda "postGlobalFilter" fonksiyonuna aÅŸaÄŸÄ±daki koÅŸulu ekliyoruz.

  if(!(exchange.getResponse().getHeaders().containsKey(filterUtility.CORRELATION_ID))) {
    logger.debug("Updated the correlation id to the outbound headers: {}", correlationId);
    exchange.getResponse().getHeaders().add(filterUtility.CORRELATION_ID, correlationId);
}


Rate Limitter Pattern;

Rate Limiter Pattern (HÄ±z SÄ±nÄ±rlama Deseni), bir sistemin belirli bir zaman aralÄ±ÄŸÄ±nda alabileceÄŸi maksimum istek (request) sayÄ±sÄ±nÄ± sÄ±nÄ±rlandÄ±ran bir yÃ¼k yÃ¶netim (throttling) desenidir.

ğŸ”§ Rate Limiter Pattern Nedir?
- Bir servis ya da sistem belirli bir trafik limitine sahiptir. Bu desende:
- Belirlenen sÄ±nÄ±r aÅŸÄ±lÄ±rsa, gelen istekler geÃ§ici olarak engellenir veya hata dÃ¶ner.
- Sistem bÃ¶ylece Ã§Ã¶kmekten korunur, kaynaklar tÃ¼kenmez ve adil kullanÄ±m saÄŸlanÄ±r.

ğŸ“Œ Ne zaman kullanÄ±lÄ±r?
- DDOS gibi aÅŸÄ±rÄ± yÃ¼k durumlarÄ±na karÅŸÄ± koruma
- Ortak kullanÄ±lan (shared) servislerin adil paylaÅŸÄ±mÄ±
- APIâ€™lerin aÅŸÄ±rÄ± tÃ¼ketilmesini engellemek
- Mikroservisler arasÄ± Ã§aÄŸrÄ±larda geri basÄ±nÃ§ (back pressure) oluÅŸturmak iÃ§in

Implementing Rate Limitter pattern in Gateway Server;

- pom.xml e aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekliyoruz.

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>


- "GatewayserverApplication" sÄ±nÄ±fÄ±na aÅŸaÄŸÄ±daki iki bean i ekliyoruz.

@Bean
public RedisRateLimiter redisRateLimiter() {
	return new RedisRateLimiter(1, 1, 1);
}

@Bean
KeyResolver userKeyResolver() {
	return exchange -> Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst("user"))
			.defaultIfEmpty("anonymous");
}

- "GatewayserverApplication" sÄ±nÄ±fÄ±nda cards router Ä±na requestRateLimiter config ini ekliyoruz.

.route(p -> p
	.path("/meryilbank/cards/**")
	.filters( f -> f.rewritePath("/meryilbank/cards/(?<segment>.*)","/${segment}")
			.addResponseHeader("X-Response-Time", LocalDateTime.now().toString())
			.requestRateLimiter(config -> config.setRateLimiter(redisRateLimiter())
					.setKeyResolver(userKeyResolver())))
	.uri("lb://CARDS")).build();
	

- application.yml a aÅŸaÄŸÄ±daki konfigÃ¼rasyonu ekliyoruz.

spring:
  data:
    redis:
      connect-timeout: 2s
      host: localhost
      port: 6379
      timeout: 1s
       
Implementing Rate Limitter pattern in accounts microservice;

- AccountsController Ä±nda getJavaVersion fonksiyonuna rate limitter Ä± uyguluyoruz aÅŸaÄŸÄ±daki gibi;

@RateLimiter(name= "getJavaVersion", fallbackMethod = "getJavaVersionFallback")
@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
return ResponseEntity.status(HttpStatus.OK).body(environment.getProperty("JAVA_HOME"));
}

public ResponseEntity<String> getJavaVersionFallback(Throwable throwable) {
return ResponseEntity
        .status(HttpStatus.OK)
        .body("Java 21");
}


- application.yml a aÅŸaÄŸÄ±daki konfigÃ¼rasyonu ekliyoruz.
      
resilience4j.ratelimiter:
  configs:
    default:
      timeoutDuration: 1000
      limitRefreshPeriod: 5000
      limitForPeriod: 1
  
NOTE;
- Docker da redis servisi ayaÄŸa kaldÄ±rÄ±yoruz.


Rate Limitter Pattern Testi iÃ§in Apache Benchmark kullanÄ±yoruz;

Kurulum;
sudo apt update
sudo apt install apache2-utils

- AÅŸaÄŸÄ±daki komut ile terminal ekranÄ±ndan istek atÄ±yoruz;
ab -n 10 -c 2 -v 3 http://localhost:8072/meryilbank/cards/api/contact-info

Apache Benchmark (ab) Nedir?

-Apache Benchmark (ab), web uygulamanÄ±zÄ±n performansÄ±nÄ± test etmek iÃ§in kullanÄ±lan hafif ve basit bir yÃ¼k testi aracÄ±dÄ±r. Genellikle bir web sunucusunun veya REST API'nin eÅŸzamanlÄ± istekleri nasÄ±l karÅŸÄ±ladÄ±ÄŸÄ±nÄ± Ã¶lÃ§mek iÃ§in kullanÄ±lÄ±r.

ğŸ”§ Ne Ä°ÅŸe Yarar?
Apache Benchmark ÅŸu sorulara yanÄ±t verir:

- Sunucum saniyede kaÃ§ isteÄŸi karÅŸÄ±layabiliyor?
- YÃ¼ksek trafikte sistem ne kadar dayanÄ±klÄ±?
- Ortalama yanÄ±t sÃ¼resi ne kadar?
- EÅŸ zamanlÄ± baÄŸlantÄ±larda performans dÃ¼ÅŸÃ¼yor mu?

ğŸ“˜ Temel Komut;
ab -n 1000 -c 10 http://localhost:8080/endpoint

AnlamÄ±:
-n 1000: Toplam 1000 istek gÃ¶nder.
-c 10: AynÄ± anda 10 isteÄŸi paralel gÃ¶nder.
URL: Test etmek istediÄŸin endpoint.


Bulkhead Pattern Nedir?
      
Bulkhead Pattern (BÃ¶lme Deseni), bir uygulamada sistem kaynaklarÄ±nÄ± izole ederek, bir bileÅŸenin Ã§Ã¶kmesinin diÄŸer bileÅŸenleri etkilemesini Ã¶nleyen bir hata toleransÄ± desenidir.

ğŸ§± 1. Bulkhead Pattern Nedir?
Bu desenin adÄ±, gemi mÃ¼hendisliÄŸinden gelir:
Gemilerde bÃ¶lmeler (bulkhead) kullanÄ±larak bir bÃ¶lÃ¼m su alÄ±rsa diÄŸer bÃ¶lÃ¼mler etkilenmesin diye izolasyon saÄŸlanÄ±r.

YazÄ±lÄ±mda da aynÄ± ÅŸekilde:
Bir servis veya iÅŸ parÃ§asÄ± aÅŸÄ±rÄ± yÃ¼k altÄ±na girerse, diÄŸer servislerin de Ã§Ã¶kmesini engellemek iÃ§in izole edilir.

ğŸ¯ 2. Ne Zaman KullanÄ±lÄ±r?
- Mikroservis mimarisinde servislerin birbirinden etkilenmemesi isteniyorsa
- YoÄŸun yÃ¼k altÄ±nda bir bileÅŸenin diÄŸer iÅŸlevleri bloke etmesini istemiyorsan
- Bir sistemde farklÄ± Ã¶nem derecesine sahip iÅŸlemler varsa (Ã¶rneÄŸin kritik vs arka plan iÅŸlemleri)






