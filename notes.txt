Springboot;
@RestController -> Rest apiler için kullanılır
@Controller -> MVC projeler için kullanılır


Maven Commands;
- mvn clean install
- mvn spring-boot:run

- java -jar target/accounts-0.0.1-SNAPSHOT.jar


Docker Commands;
- docker build . -t merveyilmas/accounts:s4
(dockerfile olan dizinde dockerfile dan image oluşturur)
- docker images
(docker image leri listeler)
- docker inspect image 6121
(image id ye göre image bilgilerini listeler)

- terminalden docker desktop a login olmak için; docker login -u merveyilmas

- docker run -p 8080:8080 merveyilmas/accounts:s4 
(image ı container içinde çalıştırır)
- docker run -d -p 8080:8080 merveyilmas/accounts:s4
(-d ile "detech" container ı arka planda çalıştırırız)
(dışarıya açılan docker port : container içerisindeki proje çalışma portu)
- docker ps
(çalışan conatiner ları listeler)
- docker ps -a
(tüm container ları listeler)
- docker start e0443edcb6ac0541e8ff46d1aa221660f755985d78ddc904ae50d7bc0c998a65
(conatiner ıd ile container çalıştırır)


Accounts Dockerfile örneği;

#Start with a base image containing Java runtime
FROM openjdk:21-jdk-slim

# MAINTAINER instruction is deprecated in favor of using label
# MAINTAINER meryil.com
#Information around who maintains the image
LABEL "org.opencontainers.image.authors"="meryil.com"

# Add the application's jar to the image
COPY target/accounts-0.0.1-SNAPSHOT.jar accounts-0.0.1-SNAPSHOT.jar

# execute the application
ENTRYPOINT ["java", "-jar", "accounts-0.0.1-SNAPSHOT.jar"]


- Dockerfile oluşturmak için buildpacks ve GoogleJib kullanabiliriz.


BUILDPACKS:

Dockerfile olmadan buildpacks ile image oluşturmak için;

1. Packaging yöntemini ekle:
<version>0.0.1-SNAPSHOT</version>
<packaging>jar</packaging>

2. Image name i ekle:
<configuration>
	<image>
		<name>merveyilmas/${project.artifactId}:s4</name>
	</image>
	<excludes>
		<exclude>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</exclude>
	</excludes>
</configuration>

- <packaging> ve <image> i ilgili yerlere ekle pom.xml de
- mvn spring-boot:build-image
(maven ile image oluşturmak için bu komutu çalıştırdık)


GOOGLE JIB:

- Jib works only java applications.

1. Google jib plugin i pom.xmle e ekle.

<plugin>
<groupId>com.google.cloud.tools</groupId>
<artifactId>jib-maven-plugin</artifactId>
<version>3.4.4</version>
<configuration>
  <to>
    <image>merveyilmas/${project.artifactId}:s4</image>
  </to>
</configuration>
</plugin> 

2. mvn compile jib:dockerBuild
(google jib ile image oluşturduk)

- mvn compile jib:build
( Bu komut ile sistemde docker yüklü olmasa bile goggle jib ile image oluşturabiliriz.)


Push image to DockerHub;
- docker image push docker.io/merveyilmas/accounts:s4

Pull image to DockerHub;
- docker image pull merveyilmas/accounts:s4


Docker Compose;

- Docker Compose, birden fazla Docker konteynerini tanımlamak ve yönetmek için kullanılan bir araçtır. Genellikle mikro hizmet mimarileri ve çoklu konteyner uygulamaları geliştirenler tarafından kullanılır. Docker Compose, bir YAML dosyasına (docker-compose.yml) servisleri, ağları, hacimleri ve konteyner ayarlarını tanımlamanıza olanak tanır.

- docker compose version

- Docker compose dosyasını istediğimiz dizinde oluşturabiliriz. Dosya ismi docker-compose.yml olmalıdır.

- docker compose up -d
(docker compose dosyasını oluşturduğumuz yerde bu komut ile container ları oluşturup, microservisleri çalıştırabiliriz)

- docker compose stop
(tüm containerları durdurur, silmez)

- docker compose down
(tüm containerlerı siler)


CLOUD NATIVE APPLICATIONS;

- Cloud-native applications (bulut yerel uygulamalar), bulut ortamlarında çalışacak şekilde tasarlanmış ve geliştirilmiş uygulamalardır. Bu tür uygulamalar, bulutun sunduğu avantajlardan tam olarak faydalanacak şekilde yapılandırılır ve genellikle mikro hizmet mimarisi, konteynerler, otomatik ölçekleme, sürekli entegrasyon/sürekli dağıtım (CI/CD) gibi modern yazılım geliştirme yaklaşımlarını kullanır.

- Örnek Teknolojiler: 
Kubernetes: Konteynerlerin orkestrasyonu.
Docker: Konteyner teknolojisi.
Prometheus: İzleme ve uyarı sistemi.
Istio: Servis ağı ve mikro hizmetler için bir yönetim platformu.
Terraform: Altyapı otomasyonu.


12-Factor App ve 15-Factor App Metodolojileri;

- 12-Factor App ve 15-Factor App metodolojileri, bulut tabanlı uygulamaların geliştirilmesi ve dağıtılması için uygulama geliştirme süreçlerinde en iyi uygulamaları tanımlar. Bu metodolojiler, modern, mikro hizmet tabanlı uygulamaların esnek, taşınabilir ve sürdürülebilir olmasını sağlamak için çeşitli yönergeler sunar.

12-Factor App Metodolojisi;

- 12-Factor App metodolojisi, her bir uygulamanın bulut ortamında verimli çalışmasını sağlayacak şekilde geliştirilmesi için 12 temel prensipten oluşur. Bu prensipler, uygulamanın taşınabilirliğini, esnekliğini ve ölçeklenebilirliğini arttırmaya yönelik ipuçları sunar. 12-Factor, özellikle bulut yerel (cloud-native) uygulamalar için önemli bir rehberdir.

12-Factor Uygulama Prensipleri:

1. Codebase (Kod Tabanı): Uygulama, tek bir kod tabanından (repository) yönetilmelidir ve her ortamda (geliştirme, test, üretim) aynı kod tabanı kullanılmalıdır.

2. Dependencies (Bağımlılıklar): Uygulamanın bağımlılıkları açıkça tanımlanmalı ve bağımsız olarak yüklenebilmelidir. Yani, uygulama bağımlılıkları dışarıdan (örneğin, package.json, pom.xml) açıkça belirtmelidir.

3. Config (Yapılandırma): Yapılandırma verileri (veritabanı bağlantı bilgileri gibi), uygulamanın içinde değil, dış bir ortamda veya çevresel değişkenlerde saklanmalıdır.

4. Backing Services (Destekleyici Servisler): Veritabanları, mesajlaşma sistemleri gibi dış servisler, uygulamanın bir parçası gibi düşünülmeli, fakat ayrı birer servis olarak ele alınmalıdır.

5. Build, Release, Run (Yapı, Yayınlama, Çalıştırma): Uygulamanın derlenmesi (build), yayına alınması (release) ve çalıştırılması (run) süreçleri ayrılmalıdır. Her aşama açıkça tanımlanmalıdır.

6. Processes (İşlemler): Uygulama, durumu taşımayan (stateless) işlemlerle çalışmalıdır. Her işlem kendi başına bağımsız olmalı ve işlem sırasındaki herhangi bir kayıp, diğer işlemleri etkilememelidir.

7. Port Binding (Port Bağlama): Uygulama, bir web sunucusunu çalıştırmak için bir port üzerinden erişilebilir olmalıdır. Uygulama dışındaki proxy sistemleri yerine, uygulamanın kendisi doğrudan HTTP veya TCP portu üzerinden dinlemelidir.

8. Concurrency (Eşzamanlılık): Uygulama, artan talepleri karşılamak için çoklu iş parçacığı (concurrency) veya işlemlerle yatay olarak ölçeklenebilir olmalıdır.

9. Disposability (Geçici Olma): Uygulama, kısa süreli yaşam döngülerine sahip olmalı ve gerektiğinde hızlıca başlatılabilir ve sonlandırılabilir olmalıdır.

10. Dev/Prod Parity (Geliştirme ve Üretim Farkı): Geliştirme, test ve üretim ortamları arasındaki farklar minimumda tutulmalıdır. Geliştiriciler ve operasyon ekipleri arasındaki kopukluk azaltılmalıdır.

11. Logs (Loglar): Uygulama, log verilerini stdout (standart çıktı) üzerinden dışarıya göndermeli ve bu loglar merkezi bir sistemde toplanmalıdır.

12. Admin Processes (Yönetici İşlemleri): Yönetici ve bakım işlemleri (örneğin, veritabanı migration'ları) uygulamanın bir parçası olarak tanımlanmalı ve çalıştırılabilir olmalıdır.

15-Factor App Metodolojisi;

- 15-Factor App metodolojisi, 12-Factor App metodolojisinin bir uzantısıdır ve 12-Factor'a ek olarak bazı ekstra faktörler ekler. Bu faktörler, bulut tabanlı uygulamaların daha etkili bir şekilde yönetilmesi, izlenmesi ve yapılandırılmasına olanak sağlar.

15-Factor Uygulama Prensipleri:

- 15-Factor App, 12-Factor metodolojisinin temeline dayanarak daha detaylı bir yapı sağlar. Ekstra faktörler şunlardır:

13. Rate Limiting (Hız Limitleme): Uygulama, dışarıya açılan API'lar ve servislerle olan etkileşimlerde hız sınırlaması yapabilmelidir. Bu, istek başına alınabilecek yanıt sayısını sınırlayarak uygulamanın aşırı yüklenmesini engeller.

14. Backups (Yedekleme): Veritabanı ve diğer kritik servisler için düzenli yedekleme stratejileri tanımlanmalıdır. Bu, felaket durumlarında veri kaybını önler.

15. Health Checks (Sağlık Kontrolleri): Uygulama, çalışma durumunu düzenli olarak kontrol edebilecek sağlık kontrolü mekanizmalarına sahip olmalıdır. Bu sayede sistem hatalarına karşı otomatik olarak yanıt verilebilir.

12-Factor ve 15-Factor Karşılaştırması;

- 12-Factor App metodolojisi, bulut ortamlarında verimli çalışan ve sürdürülebilir uygulamalar geliştirmek için temel yönergeleri sağlar.
15-Factor App metodolojisi, 12-Factor metodolojisini genişleterek uygulama yönetimi ve izleme gibi ekstra faktörler ekler. Bu, büyük ölçekli sistemlerde daha iyi bir operasyonel yönetim sağlar.


CONGIFURATION MANAGEMENT IN MICROSERVICE;

Read properties in Springboot app:

1. Using @Value annotation; 

application.yml veya application.properties dosyasına tanımladığımız değişkenlere istediğimiz yerde erişebiliriz.

ÖR;
application.yml;

build:
  version: "1.0"
  
account controller;

@Value("${build.version}")
private String buildVersion;

2. Using Environment;

- Çevresel değişkenlere erişmek için kullanırız.

ÖR;

account controller;

@Autowired
private Environment environment;

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
	return ResponseEntity.status(HttpStatus.OK).body(environment.getProperty("JAVA_HOME"));
}

Açıklama;
// jdk nın yüklü olduğu dizini verir
environment.getProperty("JAVA_HOME")

// maven ın yüklü olduğu dizini verir
environment.getProperty("MAVEN_HOME")

3. Using @ConfigurationProperties;

-Birden fazla değişkene değer tanımlamak için kullanabiliriz.

ÖR;

application.yml;

accounts:
  message: "Welcome to EazyBank accounts related local APIs "
  contactDetails:
    name: "John Doe - Developer"
    email: "john@eazybank.com"
  onCallSupport:
    - (555) 555-1234
    - (555) 523-1345

AccountsContactInfoDto;

@ConfigurationProperties(prefix = "accounts")
public record AccountsContactInfoDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {
}

AccountsApplication;

@SpringBootApplication
@EnableConfigurationProperties(value = {AccountsContactInfoDto.class})

AccountsController;

@Autowired
private AccountsContactInfoDto accountsContactInfoDto;

@GetMapping("/contact-info")
    public ResponseEntity<AccountsContactInfoDto> getContactInfo() {
        return ResponseEntity.status(HttpStatus.OK).body(accountsContactInfoDto);
    }
    
Springboot Profiles;

- application_prod.yml ve application_qa.yml isminde iki ayrı profil oluşturduk.

application_qa.yml;

spring:
  config:
    activate:
      on-profile: "qa"

build:
  version: "2.0"

accounts:
  message: "Welcome to Meryil accounts related QA APIs "
  contactDetails:
    name: "Smitha Ray - QA Lead"
    email: "smitha@meryil.com"
  onCallSupport:
    - (666) 265-3765
    - (666) 734-8371

application.yml;

spring:
  config:
    import:
      - "application_qa.yml"
      - "application_prod.yml"
  profiles:
    active:
      - "qa"
      
- application.yml dosyasında profiles.active kısmında hangi profile in ismini yazarsak o yml dosyasındaki konfigürasyonlar çalışır.


Komut Satırı ile Profile Aktif Etme;

1. Program arguments ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede program arguments kısmına 

--spring.profiles.active=prod  --build.version=1.1 

şeklinde yazarak istediğimiz değişkeni set ederiz.

2. VM options ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede modify options kısmından 'Add VM options' seçeneğine tıklarız. Açılan sekmeye ise 

-Dspring.profiles.active=prod  -Dbuild.version=1.1

şeklinde yazarak istediğimiz jvm değişkenlerini set ederiz.

3. Environment Variables ile set etme;

- Intellij idea üzerinden profili aktif etmek için AccountsApplictaion dosyasına sağ tık yapıp, more run/debug - modify run configuration e tıklarız. Ardından açılan pencerede environment variable kısmına

SPRING_PROFILES_ACTIVE=prod;BUILD_VERSION=1.8;

şeklinde yazarak istediğimiz değişkenlerini set ederiz.

- Eğer konfigürasyon dosyasında 3 alana da değişkenleri set edersek proje program arguments kısmında yazan değeri alır. 

- Eğer VM ve environment kısmında aynı aynda değişken set edilirse VM variable kısmmındaki değişkeni baz alır.

- Yani öncelik sırası;
Program arguments > VM options > Environment Variables


SPRING CLOUD CONFIG;

- Spring initializers dan spring config projesi oluşturduk.
Proje oluştururken dependency olarak "config server" ve "spring boot actuator" bağımlılıklarını seçtik.

1. Reading configurations from the class path location of config server;

- Config server projesinde "resources" dizini altına "config" klasörü ekledik. Config klasörü altına ise tüm yml dosyalarını taşıdık. (accounts.yml, accounts-prod.yml vs.) Serverconfig projesine aşağıdaki linkler ile istek atarak tanımlanan configürasyonlara erişim sağlarız.

- http://localhost:8071/accounts/default
- http://localhost:8071/accounts/prod
- http://localhost:8071/accounts/qa
- http://localhost:8071/loans/qa

- Config server a accounts, cards ve loans yml dosyaları eklendikten sonra accounts, cards ve loans projelerindeki prod ve qa konfigürasyonlarını siliyoruz.

- Accounts projesine config client dependency lerini ekliyoruz.

<properties>
	<java.version>21</java.version>
	<spring-cloud.version>2024.0.0</spring-cloud.version>
</properties>
	
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-config</artifactId>
</dependency>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>${spring-cloud.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>


- accounts projesindeki application.yml dosyasının son hali bu şekilde oluyor;

spring:
  application:
    name: accounts
  profiles:
    active: "prod"
  datasource:
    url: jdbc:mysql://localhost:3306/UdemyAccounts
    username: merve
    password: Merve123.
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      javax:
        persistence:
          validation:
            mode: none
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
  config:
    import: "optional:configserver:http://localhost:8071/"

application:
  version: 1.0.0

server:
  port: 8080

logging:
  level:
    org.springframework: error

---
application:
    name: accounts
---
- Bu kısımdaki name alanı configserver projesinde accounts projesi için oluşturulan yml dosyasının ismi ile aynı olmak zorunda.

- Aynı işlemleri lonas ve cards projeleri için de yapıyoruz.

2. Reading configurations from a file system location;
- configserver projesindeki konfigürasyonları barındıran config dosyasını kopyalayıp bilgisayarada bir dizine yapıştırdım. ("/home/merveyilmaz/Documents/config")

- Daha sonra ise configserver projesinde bulunan application.yml dosyasındaki config.server.native.search.locations kısmını dosya yolu olacak şekilde düzenliyoruz.

spring:
  application:
    name: "configserver"
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          #search-locations: "classpath:/config"
          search-locations: "file:///home/merveyilmaz/Documents/config"

3. Reading configurations from a github repository;

- github da public repository açıp config klasörü altındaki yml dosyalarını bu repository e pushluyoruz. Ardından configserver projesi altındaki application.yml dosyasında aşağıdaki düzenlemeleri yapıyoruz.

spring:
  application:
    name: "configserver"
  profiles:
    #active: native
    active: git
  cloud:
    config:
      server:
        #native:
          #search-locations: "classpath:/config"
          #search-locations: "file:///home/merveyilmaz/Documents/config"
        git:
          uri: "https://github.com/eazybytes/eazybytes-config.git"
          default-label: main
          timeout: 5
          clone-on-start: true
          force-pull: true

server:
  port: 8071


Encryption & Decryption of properties inside config server;

- config dosyamızı github a yüklediğimiz için verilerimizi göstermek istemeyiz. Config verilerini şifrelemek için configserver projesindeki application.yml dosyasına şu alanı ekleriz.

encrypt:
  key: "45D81EC1EF61DF9AD8D3E5BB397F9"

bu bizim şifreleme keyimiz olur.

http://localhost:8071/encrypt 
(body e şifrelemek istediğin text i koy body-raw-text)
http://localhost:8071/decrypt 
(body e config verisinin şifrelenmiş halini koy)

apileri ile şifreleme veya şifrelenmiş veriyi öğrenme işlemlerini gerçekleştirebiliriz.

- En son olarak ise şifrelemek istediğimiz veriyi şifreledikten sonra github da ilgili yere "{cipher}şifrelenmişveri" şeklinde güncelleriz.


Refresh configurations at runtime using REFRESH ACTUATOR PATH;

- Config dosyasında herhangi bir değişiklik yapıldığında projemiz otomatik algılasın istiyoruz.

- Mikroservislerin pom.xml dosyamızda actuator dependency i olması gerekir.

- Mikroservislerin ContactDto sınıflarını record dan normal class a dönüştürdük ki run time da herhangi bir değişiklik algılandığında değişkenler değişikliği alıgılayabilsin. 

@ConfigurationProperties(prefix = "loans")
@Getter @Setter
public class LoansContactInfoDto {

    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}

- Mikroservislerin application.yml dosyalarına şu konfigürasyonu ekliyoruz;

management:
  endpoints:
    web:
      exposure:
        include: "*"

- Githubdan accounts-prod.yml dosyasında bir string i değiştirdiğğimizde projeyi yeniden başlatmaya gerek kalmadan configürasyon dosyası proje tarafından otomatik algılanır. Githubdan string değiştirip config serverdan http://localhost:8071/accounts/prod adresine istek atarak test edebiliriz.

- Bu işlem actuator sayesinde olur.

- localhost:8080/actuator adresine istek atarak actuator ın sunduğu apileri görebiliriz.

- localhost:8080/actuator/refresh endpointi ile hangi property lerin değiştiğini görebiliriz.


Refresh configurations at runtime using Spring Cloud Bus;

- Spring cloud bus konfigürasyon dosyasınd aherhangi bir değişiklik olduğunda kaç adet mikroservis var ise hepsine aynı anda mesaj gönderir.

- Bunu rabbit mq ile yapacağız.
- Tüm mikroservis projelerimize ve configserver projemize aşağıdaki dependency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>

- Rabbitmq yu bilgisayarımıza docker komutu ile kuruyoruz
(# latest RabbitMQ 4.0.x
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management) - rabbit mq sitesinde var

- Daha sonra tüm mikroservislerdeki application.yml dosyasına rabbit mq konfigürasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
Spring Cloud Config monitor;

- Config repository de bir değişiklik olduğunda github webhook ile config servise bilgi verir. Config servis de rabbit mq ile mikroservislere mesaj gönderir. Mikroservisler de yeniden başlatılmasına gerek kalmadan kendilerini otomatik yenilerler.

- Spring Cloud Config Monitor, Spring Cloud Config Server ile birlikte çalışan bir mekanizmadır ve konfigürasyon değişikliklerini dinleyerek, ilgili mikroservisleri bu değişikliklerden haberdar eder. Bu sayede, bir servis manuel yeniden başlatılmadan yeni konfigürasyonu alabilir.

Nasıl Çalışır? 

1. Spring Cloud Config Server ile merkezi bir yapılandırma yönetimi sağlanır. Genellikle bir Git deposu kullanılır.

2. Spring Cloud Bus ile RabbitMQ veya Kafka gibi bir mesajlaşma altyapısı üzerinden mikroservislere bildirim gönderilir.

3. Spring Cloud Config Monitor, Git deposundaki yapılandırma değişikliklerini algılar ve bir Webhook (örneğin, GitHub veya GitLab Webhook’u) üzerinden bir HTTP isteği alır.

4. Gelen istek üzerine, ilgili servislere mesaj göndererek konfigürasyonlarını yenilemelerini sağlar.

- config server projesinde pom.xml dosyasına depency i ekliyoruz.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-config-monitor</artifactId>
</dependency>

- config server application.yml dosyasına aşağıdaki konfigürasyonub ekliyoruz.

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- config server application.yml dosyasına rabbit mq konfigürasyonunu ekliyoruz.

spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"
    
- Daha sonra github config dosyalarımızın bulunduğu (card-prod.yml, accounts.yml vb.) repositorymizde ayarlar kısmında webhook atif ediyoruz.


Update docker compose to adapt config server changes;

- docker-compose isminde mikroservislerin olduğu dizinde bir kalsör açtık ve daha önce oluşturduğumuz docker-compose.yml dosyasını bu kalsöre taşıdık. Son olarak configserver projemiz için de docker compose dosyasına konfigürasyonları ekledik.

- her bir mikroservis için docker-compose sayfasına enviroment değşkenleri tanımladık. 

Docker-compose dosyasının son hali;

services:
  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"

- Bu docker-compose dosyasına göre configserver container ın oluşturulması tamamlanmadan accounts containerını oluşturmaya başlayacak. Bu da mikroservislerimizin çalışmasını engel olur.


LIVENESS and READNESS probes;

- Liveness; projenin ayakta olup olmadığını kontrol eder.
- Readness; projede trafik akışı var mı onu kontrol eder.

- configserver projesindeki application.yml dosyasına konfigürasyonu ekliyoruz.

management:
  
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
        
- actuator endpointleri ile projenin liveness ve readness durumlarını kontorl edebiliriz.

- localhost:8071/actuator/health
response;
{"status":"UP","groups":["liveness","readiness"]}

- localhost:8071/actuator/health/liveness
response;
{"status":"UP"}

- eğer porjede sorun var ise status ü down olur.


Update DOCKER COMPOSE file to adapt congfig server cahnges;

- docker compose dosyasında configserver containerına healthchech konfigürasyonları ekledik.

- accounts containerına depends_on ekleyerek, config serverın sağlıklı bir şekilde çalıştığına emin olunduktan sonra account container ı oluşturulmaya başlanacak.

- spring bus kullandığımız için bizim projelerin çalışması rabbit  mq projesine de bağlı. bu yüzden compose dosyasına rabbit mq servisini de docker compose dosyamıza ekliyoruz.

- docker compose dosyasının son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
      
  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - meryilbank
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071/"
      SPRONG_PROFILES_ACTIVE: default
networks:
  meryilbank:
    driver: "bridge"


OPTIMIZE DOCKER COMPOSE FILE;

- docker-compose dosyamızda tekrar eden konfigürasyonları common-config.yml adında dosya oluşturup oraya taşıdık.

- docker-compose.yml son hali;

services:

  rabbit:
    image: rabbitmq:3.13-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    extends:
      file: common-config.yml
      service: network-deploy-service

  configserver:
    image: "merveyilmas/configserver:s6"
    container_name: configserver-ms
    ports:
      - "8071:8071"
    depends_on:
      rabbit:
        condition: service_healthy
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    extends:
      file: common-config.yml
      service: microservice-base-config

  accounts:
    image: "merveyilmas/accounts:s6"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "accounts"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  loans:
    image: "merveyilmas/loans:s6"
    container_name: loans-ms
    ports:
      - "8090:8090"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "loans"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

  cards:
    image: "merveyilmas/cards:s6"
    container_name: cards-ms
    ports:
      - "9000:9000"
    depends_on:
      configserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "cards"
    extends:
      file: common-config.yml
      service: microservice-configserver-config

networks:
  meryilbank:
    driver: "bridge"

- common-config.yml dosyası;

services:

  network-deploy-service:
    networks:
      - meryilbank

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m
    environment:
      SPRING_RABBITMQ_HOST: "rabbit"

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
      

Generate docker image and push them to docker hub;

- İlk olarak tüm projelerin google jib ile image ını oluşturuyoruz.
(mvn compile jib:dockerBuild) komutunu kullanarak proje dizininde.

- daha sonra oluşturulan imageleri 
docker image push docker.io/merveyilmas/configserver:s6
komutu ile teker teker hub a pushladık.


DOCKER COMPOSE ile container oluşturma;

- Oluşturduğumuz docker-compose/default dizinindeki docker-compose dosyamızı
docker compose up -d
komutu ile çalıştırıyoruz.

- docker compose down 
ise oluşturulan tüm containerler ı siler.


CREATE MYSQLDB FOR MICROOSERVICES;

- docker run -p 3306:3306 --name accountsdb -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=accountsdb  -d mysql
komutu ile mysql db container ı oluşturduk.


UPDATE DOCKER COMPOSE FILE TO CREATE USE MYSQL DB;

- ilk olarak mikroservislerimizin image lerini oluşturuyoruz.
(mvn compile jib:dockerBuild) komutu ile

- Daha sonra docker-compose dosyamızı güncelliyoruz, db konfigürasyonları ekliyoruz. Dockor-compose dosyamızı çalıştırmak için "docker compose up" komutunu dosyamızın olduğu dizinde çalıştırıyoruz.


SERVICE DISCOVERY & SERVIICE REGISTRATION in MICROSERVICE:


